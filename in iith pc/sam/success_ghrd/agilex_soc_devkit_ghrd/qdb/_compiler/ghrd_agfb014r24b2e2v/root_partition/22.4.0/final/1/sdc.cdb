22 serialization::archive 19 0 0 0 0 6 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 0 0 28 0 0 0 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 10 agilex_hps 36 intel_agilex_interface_generator_191 5 synth 59 agilex_hps_intel_agilex_interface_generator_191_lsv6t5y.sdc 811 if {[get_collection_size [get_nodes  -nowarn hps_inst|s2f_module~l4_mp_clk ]] > 0} {
create_clock -name hps_l4_mp_clk_src -period 5.0 [get_nodes  hps_inst|s2f_module~l4_mp_clk]
create_generated_clock -divide_by 1 -name hps_l4_mp_clk [get_registers hps_inst|s2f_module~l4_mp_clk.reg] -master_clock [get_clocks hps_l4_mp_clk_src] -source [get_nodes hps_inst|s2f_module~l4_mp_clk]
}
if {[get_collection_size [get_nodes  -nowarn hps_inst|s2f_module~emac1_gmii_txclk_cm ]] > 0} {
create_clock -name hps_emac1_gtx_clk_src -period 8.0 [get_nodes  hps_inst|s2f_module~emac1_gmii_txclk_cm]
create_generated_clock -divide_by 1 -name hps_emac1_gtx_clk [get_registers hps_inst|s2f_module~emac1_gmii_txclk_cm.reg] -master_clock [get_clocks hps_emac1_gtx_clk_src] -source [get_nodes hps_inst|s2f_module~emac1_gmii_txclk_cm]
} 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 44 emif_hps_altera_emif_arch_fm_191_ky5ybpi.sdc 52065 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing constraints of the memory device and
# of the memory interface

# ------------------------------------------- #
# -                                         - #
# --- Some useful functions and variables --- #
# -                                         - #
# ------------------------------------------- #

set script_dir [file dirname [info script]]
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_ip_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl"

#--------------------------------------------#
# -                                        - #
# --- Determine when SDC is being loaded --- #
# -                                        - #
#--------------------------------------------#

set syn_flow 0
set sta_flow 0
set fit_flow 0
set pow_flow 0
if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
   set syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
   set sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
   set fit_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_pow" } {
   set pow_flow 1
}
set ::io_only_analysis 0

# ------------------------ #
# -                      - #
# --- GENERAL SETTINGS --- #
# -                      - #
# ------------------------ #

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty

# Debug switch. Change to 1 to get more run-time debug information
set debug 0

# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_are_entity_names_on ]

# ---------------------- #
# -                    - #
# --- DERIVED TIMING --- #
# -                    - #
# ---------------------- #

# PLL multiplier to mem clk
regexp {([0-9\.]+) ps} $var(PLL_REF_CLK_FREQ_PS_STR) match var(PHY_REF_CLK_FREQ_PS)
regexp {([0-9\.]+) ps} $var(PLL_VCO_FREQ_PS_STR) match var(PHY_VCO_FREQ_PS)
set pll_multiplier [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(PHY_REF_CLK_FREQ_MHZ)] ]
set vco_multiplier [expr int($var(PHY_REF_CLK_FREQ_PS)/$var(PHY_VCO_FREQ_PS))]

# Half of memory clock cycle
set half_period [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [ expr $var(UI) / 2.0 ] ]

# Half of reference clock
set ref_period      [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [ expr $var(PHY_REF_CLK_FREQ_PS)/1000.0] ]
set ref_half_period [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [ expr $ref_period / 2.0 ] ]

# Other clock periods
set tCK_AFI     [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(USER_CLK_RATIO) ] ]
set tCK_C2P_P2C [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(C2P_P2C_CLK_RATIO) ] ]
set tCK_PHY     [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [ expr 1000.0/$var(PHY_MEM_CLK_FREQ_MHZ)*$var(PHY_HMC_CLK_RATIO) ] ]

# Asymmetric uncertainties on address and command paths
set ac_min_delay [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [ expr - $var(tIH) + $var(CA_TO_CK_BD_PKG_SKEW) ]]
set ac_max_delay [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [ expr   $var(tIS) + $var(CA_TO_CK_BD_PKG_SKEW) ]]

# ---------------------- #
# -                    - #
# --- INTERFACE RATE --- #
# -                    - #
# ---------------------- #

# -------------------------------------------------------------------- #
# -                                                                  - #
# --- This is the main call to the netlist traversal routines      --- #
# --- that will automatically find all pins and registers required --- #
# --- to apply timing constraints.                                 --- #
# --- During the fitter, the routines will be called only once     --- #
# --- and cached data will be used in all subsequent calls.        --- #
# -                                                                  - #
# -------------------------------------------------------------------- #

if { ! [ info exists emif_hps_altera_emif_arch_fm_191_ky5ybpi_sdc_cache ] } {
   emif_hps_altera_emif_arch_fm_191_ky5ybpi_initialize_ddr_db emif_hps_altera_emif_arch_fm_191_ky5ybpi_ddr_db var
   set emif_hps_altera_emif_arch_fm_191_ky5ybpi_sdc_cache 1
} else {
   if { $debug } {
      post_message -type info "SDC: reusing cached DDR DB"
   }
}

# ------------------------------------------------------------- #
# -                                                           - #
# --- If multiple instances of this core are present in the --- #
# --- design they will all be constrained through the       --- #
# --- following loop                                        --- #
# -                                                           - #
# ------------------------------------------------------------- #

set instances [ array names emif_hps_altera_emif_arch_fm_191_ky5ybpi_ddr_db ]
foreach { inst } $instances {
   if { [ info exists pins ] } {
      unset pins
   }
   array set pins $emif_hps_altera_emif_arch_fm_191_ky5ybpi_ddr_db($inst)

   # ----------------------- #
   # -                     - #
   # --- REFERENCE CLOCK --- #
   # -                     - #
   # ----------------------- #

   # First determine if a reference clock has already been created (i.e. Reference clock sharing)
   set ref_clock_exists [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_does_ref_clk_exist $pins(pll_ref_clock) ]
   if { $ref_clock_exists == 0 }  {
      # This is the reference clock used by the PLL to derive any other clock in the core
      create_clock -period "$var(PHY_REF_CLK_FREQ_MHZ)MHz" -waveform [ list 0 $ref_half_period ] $pins(pll_ref_clock) -add -name ${inst}_ref_clock
   }
   set pins(ref_clock_name) [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_clock_name_from_pin_name $pins(pll_ref_clock)]

   # ------------------ #
   # -                - #
   # --- PLL CLOCKS --- #
   # -                - #
   # ------------------ #

   # VCO clock
   #We also detect and save the index of the clocks that drive the CPAs
   set is_master [expr {([string compare $inst $pins(master_instname)] == 0) ? 1 : 0}]
   set i_vco_clock 0
   set i_cpa_clock_tile_pri -1
   set i_cpa_clock_tile_sec -1
   foreach { vco_clock } $pins(pll_vco_clock) {

      set suffix "_${i_vco_clock}"
      if {$vco_clock == $pins(master_vco_clock)} {
         set suffix ""
         if {$is_master} {
            set i_cpa_clock_tile_pri $i_vco_clock
         }
      } elseif {$vco_clock == $pins(master_vco_clock_sec)} {
         if {$is_master} {
            set i_cpa_clock_tile_sec $i_vco_clock
         }
      }

      set local_pll_vco_clk_${i_vco_clock} [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
         -target $vco_clock \
         -name "${inst}_vco_clk${suffix}" \
         -source $pins(pll_ref_clock) \
         -multiply_by [expr $vco_multiplier ]  \
         -divide_by 1 \
         -phase 0 ]
      incr i_vco_clock
   }
   
   if {! $var(IS_HPS)} {
      if {$is_master} {
         if {$i_cpa_clock_tile_pri == -1} {
            post_message -type critical_warning "Failed to find CPA clock index"
         }
         if {$i_cpa_clock_tile_sec == -1 && $var(PHY_PING_PONG_EN)} {
            post_message -type critical_warning "Failed to find CPA clock index for secondary interface"
         }
      }
   }

   # Core clocks
   set core_clocks [list]
   set core_clocks_local [list]

   # Skip if we're in HPS mode since there's no user accessible core clock
   # and there's no transfers within core fabric to analyze
   if {! $var(IS_HPS)} {

      set local_pll_master_vco_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
         -target $pins(master_vco_clock) \
         -name "${pins(master_instname)}_vco_clk" \
         -source $pins(pll_ref_clock) \
         -multiply_by [expr $vco_multiplier ]  \
         -divide_by 1 \
         -phase 0 ]

      # emif_usr_clk
      # Clock only exists when HMC is used.
      set local_core_usr_clock ""
      if {$pins(master_core_usr_clock) != ""} {
         set name "core_usr_clk"
         set master_core_clock $pins(master_core_usr_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_clock)
         lappend core_clocks_local $local_core_usr_clock 
      }
      
      # emif_usr_clk_sec
      # Clock only exists when ping-pong HMC is used
      set local_core_usr_clock_sec ""
      if {$pins(master_core_usr_clock_sec) != ""} {
         set name "core_usr_clk_sec"
         set master_core_clock_sec $pins(master_core_usr_clock_sec)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_clock_sec [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
            -target $master_core_clock_sec \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock_sec) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_clock_sec)
         lappend core_clocks_local $local_core_usr_clock_sec 
      }      

      # emif_usr_half_clk
      # Clock only exists when HMC is used and in 2x bridge mode
      set local_core_usr_half_clock ""
      if {$pins(master_core_usr_half_clock) != ""} {
         set name "core_usr_half_clk"
         set master_core_clock $pins(master_core_usr_half_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_half_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_half_clock)
         lappend core_clocks_local $local_core_usr_half_clock
      }
      
      # emif_usr_half_clk
      # Clock only exists when ping-pong HMC is used and in 2x bridge mode
      set local_core_usr_half_clock_sec ""
      if {$pins(master_core_usr_half_clock_sec) != ""} {
         set name "core_usr_half_clk_sec"
         set master_core_clock_sec $pins(master_core_usr_half_clock_sec)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) * 2}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_usr_half_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
            -target $master_core_clock_sec \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock_sec) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_usr_half_clock_sec)
         lappend core_clocks_local $local_core_usr_half_clock
      }      

      # afi_clk
      # Clock only exists when HMC isn't used.
      set local_core_afi_clock ""
      if {$pins(master_core_afi_clock) != ""} {
         set name "core_afi_clk"
         set master_core_clock $pins(master_core_afi_clock)
         if {$var(USER_CLK_RATIO) == 8} {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO) / 2}]
         } else {
            set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         }
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_afi_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_afi_clock)
         lappend core_clocks_local $local_core_afi_clock
      }

      # extra CPA output for PE test purpose.
      set local_core_dft_cpa_1_clock "" 
      if {$pins(master_core_dft_cpa_1_clock) != ""} {
         set name "core_dft_cpa_1_clk"
         set master_core_clock $pins(master_core_dft_cpa_1_clock)
         set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(USER_CLK_RATIO)}]
         set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

         set local_core_dft_cpa_1_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
            -target $master_core_clock \
            -name "${pins(master_instname)}_${name}" \
            -source $pins(master_vco_clock) \
            -multiply_by 1 \
            -divide_by $divide_by\
            -phase $phase ]

         lappend core_clocks $pins(master_core_dft_cpa_1_clock)
         lappend core_clocks_local $local_core_dft_cpa_1_clock
      }
      
      # Calibration master logic clock
      if {$pins(master_cal_master_clk) != ""} {
         set pll_cal_master_clk [get_pins -nowarn $pins(master_cal_master_clk)]

         if {[get_collection_size $pll_cal_master_clk] > 0} {
            set name              "core_cal_master_clk"
            set master_core_clock $pins(master_cal_master_clk)
            set divide_by         $var(pll_c4_cnt) 
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_4) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c4_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_4)
            
            set local_cal_master_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]

            lappend core_clocks $pins(master_cal_master_clk)
            lappend core_clocks_local $local_cal_master_clock
         }
      }
      
      # Calibration slave logic clock
      if {$pins(master_cal_slave_clk) != ""} {
         set pll_cal_slave_clk [get_pins -nowarn $pins(master_cal_slave_clk)]

         if {[get_collection_size $pll_cal_slave_clk] > 0} {
            set name              "core_cal_slave_clk"
            set master_core_clock $pins(master_cal_slave_clk)
            set divide_by         $var(pll_c3_cnt) 
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_3) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c3_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_3)
            
            set local_cal_slave_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]

            lappend core_clocks $pins(master_cal_slave_clk)
            lappend core_clocks_local $local_cal_slave_clock
         }
      }

      # Optional PLL Extra clocks
      for {set i_extra_clk 0} {$i_extra_clk < $var(PLL_NUM_OF_EXTRA_CLKS)} {incr i_extra_clk} {
         set pll_extra_clk [get_pins -nowarn $pins(pll_extra_clk_${i_extra_clk})]

         # PLL counter may not exist if clock isn't actually connected and used
         if {[get_collection_size $pll_extra_clk] > 0} {
            set i_clk_cnt_num     [expr {$i_extra_clk + $var(pll_num_of_reserved_cnts)}]
            set name              "core_extra_clk_${i_extra_clk}"
            set master_core_clock $pins(pll_extra_clk_${i_extra_clk})
            set divide_by         $var(pll_c${i_clk_cnt_num}_cnt)
            set phase             [expr { [lindex $var(PLL_C_CNT_PHASE_PS_STR_${i_clk_cnt_num}) 0] * 360.0 / $var(PHY_VCO_FREQ_PS) / $var(pll_c${i_clk_cnt_num}_cnt) } ]
            set duty_cyc          $var(PLL_C_CNT_DUTY_CYCLE_${i_clk_cnt_num})

            set local_pll_extra_clock [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
               -target $master_core_clock \
               -name "${pins(master_instname)}_${name}" \
               -source $pins(master_vco_clock) \
               -multiply_by 1  \
               -divide_by $divide_by  \
               -phase $phase \
               -duty_cycle $duty_cyc ]
         }
      }
   }

   # Periphery clocks
   set periphery_clocks [list]
   set i_phy_clock 0
   foreach { phy_clock } $pins(pll_phy_clock) {
      set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(PHY_HMC_CLK_RATIO)}]
      set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

      set local_phy_clk_${i_phy_clock} [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
         -target $phy_clock \
         -name "${inst}_phy_clk_${i_phy_clock}" \
         -source [lindex $pins(pll_vco_clock) $i_phy_clock] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_${i_phy_clock}]
      incr i_phy_clock
   }

   set i_phy_clock_l 0
   foreach { phy_clock_l } $pins(pll_phy_clock_l) {
      set divide_by [expr {$var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO) * $var(C2P_P2C_CLK_RATIO)}]
      set phase [expr {$var(PLL_PHY_CLK_VCO_PHASE) * 45.0 / $divide_by}]

      set local_phy_clk_l_${i_phy_clock_l} [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
         -target $phy_clock_l \
         -name "${inst}_phy_clk_l_${i_phy_clock_l}" \
         -source [lindex $pins(pll_vco_clock) $i_phy_clock_l] \
         -multiply_by 1 \
         -divide_by $divide_by \
         -phase $phase ]
      lappend periphery_clocks [set local_phy_clk_l_${i_phy_clock_l}]
      incr i_phy_clock_l
   }

   # ------------------------ #
   # -                      - #
   # --- WRITE FIFO CLOCK --- #
   # -                      - #
   # ------------------------ #

   set write_fifo_clk [get_keepers ${inst}*|tile_gen[*].lane_gen[*].lane_inst|lane_inst~out_phy_reg]

   set i_wf_clock 0
   foreach_in_collection wf_clock $write_fifo_clk {
      set vco_clock_id [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_vco_clk_id $wf_clock var]
      if {$vco_clock_id == -1} {
         post_message -type critical_warning "Failed to find VCO clock"
      } else {
         set local_wf_clk_${i_wf_clock} [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock \
           -target [get_node_info -name $wf_clock] \
           -name "${inst}_wf_clk_${i_wf_clock}" \
           -source [get_node_info -name $vco_clock_id] \
           -multiply_by 1 \
           -divide_by [expr $var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO)] \
           -phase 0 ]        
      }   
      incr i_wf_clock     
   }      

   # ---------------- #
   # -              - #
   # --- A/C PATH --- #
   # -              - #
   # ---------------- #

   # Only during the Fitter do we need to have constraints to allow for auto-delay chain code to
   # pick appropirate good settings
   # Also, only need it if address/command is not calibrated
   if {($fit_flow == 1) && ($var(CA_DESKEW) == 0)} {

      # First, define CK and CK#clocks because A/C timing is defined w.r.t. to these.
      set master_ck_clock ""
      foreach ac_clk_pin $pins(ac_clk) ac_clk_pin_n $pins(ac_clk_n) {
         set master_ck_clock [get_fanins $ac_clk_pin]
         foreach_in_collection check_pin $master_ck_clock {
            set check_pin_name [get_node_info -name $check_pin]
            if {[regexp {out_phy_reg$} $check_pin_name]} {
               set master_ck_clock $check_pin_name
               break
            }
         }
         create_generated_clock -multiply_by 1 -source $master_ck_clock $ac_clk_pin -name $ac_clk_pin     
         create_generated_clock -multiply_by 1 -invert -source $master_ck_clock $ac_clk_pin_n -name $ac_clk_pin_n     
      }
   
      foreach { ac_clk_pin } $pins(ac_clk) {
         # ac_pins can contain input ports such as mem_err_out_n
         # Loop through each ac pin to make sure we only apply set_output_delay to output ports
         foreach { ac_pin } $pins(ac_sync) {
            set ac_port [ get_ports $ac_pin ]
            if {[get_collection_size $ac_port] > 0} {
               if [ get_port_info -is_output_port $ac_port ] {
                  # Specifies the minimum delay difference between the DQS pin and the address/control pins:
                  set_output_delay -min $ac_min_delay -clock [get_clocks $ac_clk_pin] $ac_port -add_delay

                  # Specifies the maximum delay difference between the DQS pin and the address/control pins:
                  set_output_delay -max $ac_max_delay -clock [get_clocks $ac_clk_pin] $ac_port -add_delay
               }
            }
         }
      }
   } else {
      set_false_path -to $pins(ac_sync)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_sync)
   }


   # ----------------- #
   # -               - #
   # --- READ PATH --- #
   # -               - #
   # ----------------- #

   foreach { read_clock } $pins(rclk) {
      create_clock -period "$var(PHY_MEM_CLK_FREQ_MHZ)MHz" -waveform [ list 0 $half_period ] $read_clock -name ${read_clock}_IN -add
   }

   # ------------------------------ #
   # -                            - #
   # --- MULTICYCLE CONSTRAINTS --- #
   # -                            - #
   # ------------------------------ #
   
   if {!$var(IS_HPS)} {

      # Relax timing to the input of the synchronizer for the local_reset_req signal
      # setup=7 and hold=6 are somewhat arbitrary choices
      if {$is_master} {
         set tmp "${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|local_reset_req_sync_gen_master.local_reset_req_sync_inst|din_s1"
         set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
         set tmp_reg [get_registers -nowarn $tmp]
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }

      # Soft reset synchronizers
      # See RTL for the justification of setup=7 and hold=6
      set tmp "${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync*"
      set tmp_pin [get_pins -nowarn ${inst}|arch|arch_inst|non_hps.core_clks_rsts_inst|*reset_sync*|clrn]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold 6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }

      # seq2core_reset_done comes out of the PHY at up to 666MHz. Needs to be treated as async with synchronizer in the core.
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.seq2core_reset_done_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      
      
      # ac_parity_err 
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.seq2core_ac_parity_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }

      # afi_cal_in_progress (used by cal_counter module)
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_in_progress_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }
      
      # afi_cal_success
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_success_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      
      
      # afi_cal_fail
      # setup=7 and hold=6 are somewhat arbitrary choices
      set tmp "${inst}|arch|arch_inst|seq_if_inst|non_hps.afi_cal_fail_sync_inst|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      

      # cal_counter synchronizer for global_reset_n_int
      set tmp "${inst}|arch|arch_inst|cal_counter_inst|non_hps.inst_sync_reset_n|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }      
      }
      
      # cal_counter synchronizer for afi_cal_in_progress
      set tmp "${inst}|arch|arch_inst|cal_counter_inst|non_hps.inst_sync_cal_in_progress|din_s1"
      set tmp_pin [get_pins -nowarn [list "${tmp}|d" "${tmp}|*data"]]
      set tmp_reg [get_registers -nowarn $tmp]
      if {[get_collection_size $tmp_pin] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through $tmp_pin -to $tmp -setup 7 -end
            set_multicycle_path -through $tmp_pin -to $tmp -hold  6 -end
         } else {
            set_false_path -through $tmp_pin -to $tmp_reg
         }
      }      

      set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[6]]
      if {[get_collection_size $tmp] > 0} {
         set_multicycle_path -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through $tmp -from [get_keepers *reset*] -setup 3 -end
         set_multicycle_path -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through $tmp -from [get_keepers *reset*] -hold  2 -end
      }

      if {$var(PHY_USERMODE_OCT)} {
         set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19]]
         if {[get_collection_size $tmp] > 0} {
            set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.oct_cal_req_regs* -setup 4 -start
            set_multicycle_path -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_ctl2core[19] -to *gen_oct_cal_req.gen_oct_cal_req_no_hps.oct_cal_req_regs* -hold  3 -start
         }

         set tmp [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7]]
         if {[get_collection_size $tmp] > 0} {
            set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|regs.sr_out* -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7] -setup 4 -start
            set_multicycle_path -from ${inst}|arch|arch_inst|seq_if_inst|gen_oct_cal_rdy.gen_oct_cal_rdy_no_hps.oct_cal_rdy_regs|regs.sr_out* -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst~hmc_reg0 -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].tile_ctrl_inst|afi_core2ctl[7] -hold  3 -start
         }
      }

      set ufi_wr [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ufi_write_reg]
      set ufi_rd [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ufi_read_reg]

      if {([get_collection_size $ufi_wr] > 0) && ([get_collection_size $ufi_rd] > 0)} {
         set_multicycle_path -from $ufi_wr -to $ufi_rd -setup 1 -end
         set_multicycle_path -from $ufi_wr -to $ufi_rd -hold  1 -end
      }
   }

   if {$var(AMM_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*amm_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(AMM_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*amm_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(MMR_C2P_UFI_MODE)!= "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*mmr_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(MMR_P2C_UFI_MODE)!= "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*mmr_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SEQ_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*seq_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*hmc_reg* -0.200
      }
   }
   if {$var(SEQ_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*seq_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*hmc_reg* -0.200
      }
   }
   if {$var(ECC_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ecc_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(ECC_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*ecc_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(LANE_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*lane_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(LANE_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*lane_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SIDEBAND_C2P_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*sideband_c2p_ufi_i|*ufi_read_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -from $ufi_reg -to ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   if {$var(SIDEBAND_P2C_UFI_MODE) != "pin_ufi_use_in_direct_out_direct"} {
      set ufi_reg [get_keepers -nowarn ${inst}|arch|arch_inst|fm_ufis|*sideband_p2c_ufi_i|*ufi_write_reg]
      if {[get_collection_size $ufi_reg] > 0} {
         set_min_delay -to $ufi_reg -from ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|*phy_reg* -0.200
      }
   }
   
   foreach periphery_clock $periphery_clocks {
      set_clock_uncertainty -10ps -add -enable_same_physical_edge -hold -from [get_clocks $periphery_clock] -to [get_clocks $periphery_clock]
   }

   if {!$var(IS_HPS)} {
      set dll_reset [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2]]
      if {[get_collection_size $dll_reset] > 0} {
         if {$fit_flow == 1} {
            set_multicycle_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2] -setup 8 -end
            set_multicycle_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2] -hold  7 -end
         } else {
            set_false_path -through ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core_dll[2]
         }
      }
   }

   # ------------------------------ #
   # -                            - #
   # --- FALSE PATH CONSTRAINTS --- #
   # -                            - #
   # ------------------------------ #

   if {$var(C2C_TG_FALSE_PATH)} {
      set_false_path -from tg|tg|* -to tg|tg|*
   }   

   
   foreach ac_buf_path [concat $var(PATTERNS_AC_CLK) $var(PATTERNS_AC_SYNC) $var(PATTERNS_AC_ASYNC)] {
     set length [string length $ac_buf_path]
     set last_char [string range $ac_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {

        set word_idx [string first "cal_oct" $ac_buf_path]
        if {$word_idx == -1 } {
            set word_idx [string first "no_oct" $ac_buf_path]
            set suffix "no_oct.obuf"
        } else {
            set suffix "cal_oct.obuf"
        }
        set sub_path [string range $ac_buf_path 0 [expr {$word_idx - 1}]]

        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"

        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }


   foreach ac_n_buf_path $var(PATTERNS_AC_CLK_N) {
     set length [string length $ac_n_buf_path]
     set last_char [string range $ac_n_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {

        set word_idx [string first "cal_oct" $ac_n_buf_path]
        if {$word_idx == -1 } {
            set word_idx [string first "no_oct" $ac_n_buf_path]
            set suffix "no_oct.obuf_bar"
        } else {
            set suffix "cal_oct.obuf_bar"
        }
        set sub_path [string range $ac_n_buf_path 0 [expr {$word_idx - 1}]]

        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"

        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }


   foreach dqdqs_buf_path [concat $var(PATTERNS_WCLK) $var(PATTERNS_WDATA) $var(PATTERNS_DBI) $var(PATTERNS_DM)] {
     set length [string length $dqdqs_buf_path]
     set last_char [string range $dqdqs_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {
        set word_idx [string first "cal_oct" $dqdqs_buf_path]
        set suffix "cal_oct.obuf"
        
        set sub_path [string range $dqdqs_buf_path 0 [expr {$word_idx - 1}]]
        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"
        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   } 

   foreach dqdqs_buf_path $var(PATTERNS_WCLK_N) {
     set length [string length $dqdqs_buf_path]
     set last_char [string range $dqdqs_buf_path [expr $length -1] [expr $length -1]]
     
     if {[string equal $last_char "o"] == 1} {
        set word_idx [string first "cal_oct" $dqdqs_buf_path]
        set suffix "cal_oct.obuf_bar"
        
        set sub_path [string range $dqdqs_buf_path 0 [expr {$word_idx - 1}]]
        set buf_path ${inst}|${sub_path}${suffix}
        set oe_path  "${buf_path}|oe"
        set_false_path -through $oe_path
        set_disable_timing -from oe -to o $buf_path
      }
   }

   # DQ/DQS pins are calibrated
   set_false_path -to $pins(wdata)
   set_false_path -from $pins(rdata)
   set_output_delay -clock $pins(ref_clock_name) 0 $pins(wdata)
   set_input_delay -clock $pins(ref_clock_name) 0 $pins(rdata)
   if {[llength $pins(dm)] > 0} {
      set_false_path -to $pins(dm)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dm)
   }
   if {[llength $pins(dbi)] > 0} {
      set_false_path -to $pins(dbi)
      set_false_path -from $pins(dbi)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(dbi)
      set_input_delay -clock $pins(ref_clock_name) 0 $pins(dbi)
   }
   set_false_path -to $pins(wclk)
   set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk)
   if {[llength $pins(wclk_n)] > 0} {
      set_false_path -to $pins(wclk_n)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(wclk_n)
   }
   set_false_path -from $pins(rclk)
   if {[llength $pins(rclk_n)] > 0} {
      set_false_path -from $pins(rclk_n)
   }
   if {[llength $pins(ac_clk)] > 0} {
      set_false_path -to $pins(ac_clk)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk) -add
   }
   if {[llength $pins(ac_clk_n)] > 0} {
      set_false_path -to $pins(ac_clk_n)
      set_output_delay -clock $pins(ref_clock_name) 0 $pins(ac_clk_n) -add
   }

   if {[llength $pins(ac_async)] > 0} {
      set_false_path -to $pins(ac_async)
      set_false_path -from $pins(ac_async)
      foreach ac_async $pins(ac_async) {
         if {[get_port_info -is_input $ac_async] || [get_port_info -is_inout $ac_async]} {
            set_input_delay -clock $pins(ref_clock_name) 0 $ac_async
         }
         if {[get_port_info -is_output $ac_async] || [get_port_info -is_inout $ac_async]} {
            set_output_delay -clock $pins(ref_clock_name) 0 $ac_async
         }
      }
   }
   
   if {!$var(IS_HPS)} {
      set tmp_pins_0 [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|core2dbc_rd_data_rdy]
      set tmp_pins_1 [get_pins -nowarn ${inst}|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen[*].lane_gen[*].lane_inst|lane_inst|dbc2core_rd_data_vld0]
      if {[get_collection_size $tmp_pins_0] > 0 && [get_collection_size $tmp_pins_1] > 0} {
         set_false_path -through $tmp_pins_0 -through $tmp_pins_1
      }
   }

   # ------------------------- #
   # -                       - #
   # --- CLOCK UNCERTAINTY --- #
   # -                       - #
   # ------------------------- #

   if {!$var(IS_HPS) && ($fit_flow == 1 || $sta_flow == 1)} {

      #################################
      # C2P/P2C transfers
      #################################

      # Get P2C / C2P Multi-tile clock uncertainty
      set p2c_c2p_multi_tile_clock_uncertainty [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_p2c_c2p_clock_uncertainty $inst var]

      # Get extra periphery clock uncertainty
      set periphery_clock_uncertainty [list]
      emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_periphery_clock_uncertainty periphery_clock_uncertainty var

      # Get Fitter overconstraints
      if {$fit_flow == 1} {
         emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_periphery_overconstraints periphery_overconstraints_st periphery_overconstraints_mt var
      } else {
         set periphery_overconstraints_st [list 0.0 0.0 0.0 0.0]
         set periphery_overconstraints_mt [list 0.0 0.0 0.0 0.0]
      }

      # Now loop over core/periphery clocks and set clock uncertainty
      set i_core_clock 0
      foreach core_clock $core_clocks {
         if {$core_clock != ""} {

            set local_core_clock [lindex $core_clocks_local $i_core_clock]
            
            if {$core_clock == $pins(master_core_usr_clock_sec) || $core_clock == $pins(master_core_usr_half_clock_sec)} {
               set same_tile_index $i_cpa_clock_tile_sec
            } else {
               set same_tile_index $i_cpa_clock_tile_pri
            }

            set i_phy_clock 0
            foreach { phy_clock } $pins(pll_phy_clock_l) {
               
               if {$i_phy_clock != $same_tile_index} {
                  # C2P/P2C where the periphery tile != CPA tile.
                  # For these transfers the SDC explicitly overrides the clock uncertainty values.
                  # Therefore, when overconstraining we must not use the "-add" option.
                  set add_to_derived ""
                  set c2p_su         [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 0] + [lindex $periphery_clock_uncertainty 0]}]
                  set c2p_h          [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 1] + [lindex $periphery_clock_uncertainty 1]}]
                  set p2c_su         [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 2] + [lindex $periphery_clock_uncertainty 2]}]
                  set p2c_h          [expr {$p2c_c2p_multi_tile_clock_uncertainty + [lindex $periphery_overconstraints_mt 3] + [lindex $periphery_clock_uncertainty 3]}]
               } else {
                  # C2P/P2C where the periphery tile == CPA tile
                  # For these transfers it is safe to use the -add option since we rely on 
                  # derive_clock_uncertainty for the base value.
                  set add_to_derived "-add"
                  set c2p_su         [expr [lindex $periphery_overconstraints_st 0] + [lindex $periphery_clock_uncertainty 0]]
                  set c2p_h          [expr [lindex $periphery_overconstraints_st 1] + [lindex $periphery_clock_uncertainty 1]]
                  set p2c_su         [expr [lindex $periphery_overconstraints_st 2] + [lindex $periphery_clock_uncertainty 2]]
                  set p2c_h          [expr [lindex $periphery_overconstraints_st 3] + [lindex $periphery_clock_uncertainty 3]]
               }

               set catch_exception [catch {set local_phy_clk_l_${i_phy_clock}} result]
               if {$catch_exception == 0} {
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $c2p_su
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $c2p_h
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $p2c_su
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $p2c_h
                  
                  if {$sta_flow == 1 && $var(CUT_C2P_P2C_PATHS)} {
                     set_false_path -to [get_clocks [set local_phy_clk_l_${i_phy_clock}]] 
                     set_false_path -from [get_clocks [set local_phy_clk_l_${i_phy_clock}]] 
                  }
               }

               set catch_exception [catch {set local_phy_clk_${i_phy_clock}} result]
               if {$catch_exception == 0} {
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $c2p_su
                  set_clock_uncertainty -from [get_clocks $local_core_clock] -to   [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $c2p_h
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -setup {*}$add_to_derived $p2c_su
                  set_clock_uncertainty -to   [get_clocks $local_core_clock] -from [get_clocks [set local_phy_clk_${i_phy_clock}]] -suppress_warnings -hold  {*}$add_to_derived $p2c_h
                  
                  if {$sta_flow == 1 && $var(CUT_C2P_P2C_PATHS) } {
                     set_false_path -to [get_clocks [set local_phy_clk_${i_phy_clock}]] 
                     set_false_path -from [get_clocks [set local_phy_clk_${i_phy_clock}]] 
                  }
               
               }

               incr i_phy_clock
            }
         }
         incr i_core_clock
      }

      #################################
      # Within-core transfers
      #################################

      # Get extra core clock uncertainty
      set core_clock_uncertainty [list]
      emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_core_clock_uncertainty core_clock_uncertainty var

      # Get Fitter overconstraints
      if {$fit_flow == 1} {
         emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_core_overconstraints core_overconstraints var
      } else {
         set core_overconstraints [list 0.0 0.0 0.0 0.0]
      }

      set c2c_same_su         [expr [lindex $core_overconstraints 0] + [lindex $core_clock_uncertainty 0]]
      set c2c_same_h          [expr [lindex $core_overconstraints 1] + [lindex $core_clock_uncertainty 1]]
      set c2c_diff_su         [expr [lindex $core_overconstraints 2] + [lindex $core_clock_uncertainty 2]]
      set c2c_diff_h          [expr [lindex $core_overconstraints 3] + [lindex $core_clock_uncertainty 3]]

      # For these transfers it is safe to use the -add option of set_clock_uncertainty since
      # we rely on derive_clock_uncertainty for the base value.
      foreach src_core_clock_local $core_clocks_local {
         if {$src_core_clock_local != ""} {
            foreach dst_core_clock_local $core_clocks_local {
               if {$dst_core_clock_local != ""} {
                  if {$src_core_clock_local == $dst_core_clock_local} {
                     # Same clock network transfers
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -setup -add $c2c_same_su
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -hold -enable_same_physical_edge -add $c2c_same_h
                  } else {
                     # Transfers between different core clock networks
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -setup -add $c2c_diff_su
                     set_clock_uncertainty -from $src_core_clock_local -to $dst_core_clock_local -hold -add $c2c_diff_h
                  }
               }
            }
         }
      }

   }

   # --------------------- #
   # -                   - #
   # --- ACTIVE CLOCKS --- #
   # -                   - #
   # --------------------- #

   if {(($::quartus(nameofexecutable) ne "quartus_fit") && ($::quartus(nameofexecutable) ne "quartus_map"))} {

      if {$var(C2P_P2C_PR) && [llength $periphery_clocks] > 0 && !$debug} {
         post_sdc_message info "Setting periphery clocks as inactive; use Report DDR to timing analyze periphery clocks"
         set_active_clocks [remove_from_collection [get_active_clocks] [get_clocks $periphery_clocks]]
      }
   }
}

# -------------------------- #
# -                        - #
# --- REPORT DDR COMMAND --- #
# -                        - #
# -------------------------- #

add_ddr_report_command "source [list [file join [file dirname [info script]] ${::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename}_report_timing.tcl]]"

 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 58 emif_hps_altera_emif_arch_fm_191_ky5ybpi_ip_parameters.tcl 39715 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the memory device and
# of the memory interface

package require ::quartus::clock_uncertainty


set ::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename emif_hps_altera_emif_arch_fm_191_ky5ybpi

set var(PROTOCOL)                                                DDR4
set var(NUM_RANKS)                                               1
set var(SLEW_RATE_DRAM)                                          4.0
set var(SLEW_RATE_DRAM_CLOCK)                                    8.0
set var(VIN_Ms)                                                  0.11
set var(VIN_Mh)                                                  0.055
set var(SLEW_RATE_PHY)                                           2.0
set var(SLEW_RATE_PHY_CLOCK)                                     4.0
set var(SLEW_RATE_CA)                                            2.0
set var(SLEW_RATE_CLOCK)                                         4.0
set var(UI)                                                      0.833
set var(tCK)                                                     0.625
set var(tDQSQ)                                                   0.043750000000000004
set var(tQH)                                                     0.43
set var(tDS)                                                     0.04791666666666667
set var(tDH)                                                     0.04791666666666667
set var(tIS)                                                     0.04
set var(tIH)                                                     0.065
set var(tDQSCK)                                                  0.17
set var(tDQSS)                                                   0.27
set var(tWLS)                                                    0.108
set var(tWLH)                                                    0.108
set var(tDSS)                                                    0.18
set var(tDSH)                                                    0.18
set var(BD_PKG_SKEW)                                             0.02
set var(CA_BD_PKG_SKEW)                                          0.18
set var(CA_TO_CK_BD_PKG_SKEW)                                    0.0
set var(DQS_BOARD_SKEW)                                          0.02
set var(DQS_TO_CK_BOARD_SKEW)                                    0.02
set var(RD_ISI)                                                  0.075
set var(WR_ISI)                                                  0.09
set var(CA_ISI)                                                  0.15
set var(DQSG_ISI)                                                0.15
set var(WL_ISI)                                                  0.038
set var(X4)                                                      0
set var(IS_DLL_ON)                                               1
set var(OCT_RECAL)                                               1
set var(RDBI)                                                    1
set var(WDBI)                                                    1
set var(CUT_C2P_P2C_PATHS)                                       0
set var(CA_DESKEW)                                               1

set var(PHY_TARGET_SPEEDGRADE)                                   E2V
set var(PHY_TARGET_IS_ES)                                        false
set var(PHY_TARGET_IS_ES2)                                       false
set var(PHY_TARGET_IS_ES3)                                       true
set var(PHY_TARGET_IS_PRODUCTION)                                false
set var(PHY_CORE_CLKS_SHARING_ENUM)                              CORE_CLKS_SHARING_DISABLED
set var(PHY_CONFIG_ENUM)                                         CONFIG_PHY_AND_HARD_CTRL
set var(PHY_PING_PONG_EN)                                        false
set var(IS_HPS)                                                  true
set var(PHY_MEM_CLK_FREQ_MHZ)                                    1200.0
set var(PHY_REF_CLK_FREQ_MHZ)                                    100.0
set var(PHY_REF_CLK_JITTER_PS)                                   10.0
set var(PLL_REF_CLK_FREQ_PS_STR)                                 "10008 ps"
set var(PLL_VCO_FREQ_PS_STR)                                     "834 ps"
set var(PLL_VCO_TO_MEM_CLK_FREQ_RATIO)                           1
set var(PLL_PHY_CLK_VCO_PHASE)                                   0
set var(USER_CLK_RATIO)                                          4
set var(C2P_P2C_CLK_RATIO)                                       4
set var(PHY_HMC_CLK_RATIO)                                       4
set var(MEM_FORMAT_ENUM)                                         MEM_FORMAT_DISCRETE
set var(MEM_DATA_MASK_EN)                                        true
set var(DIAG_TIMING_REGTEST_MODE)                                false
set var(DIAG_CPA_OUT_1_EN)                                       false
set var(DIAG_USE_CPA_LOCK)                                       true
set var(PHY_USERMODE_OCT)                                        false
set var(AMM_C2P_UFI_MODE)                                        pin_ufi_use_delay_fifo_out_reg
set var(AMM_P2C_UFI_MODE)                                        pin_ufi_use_fast_fifo_out_reg
set var(MMR_C2P_UFI_MODE)                                        pin_ufi_use_delay_fifo_out_reg
set var(MMR_P2C_UFI_MODE)                                        pin_ufi_use_fast_fifo_out_reg
set var(SIDEBAND_C2P_UFI_MODE)                                   pin_ufi_use_delay_fifo_out_reg
set var(SIDEBAND_P2C_UFI_MODE)                                   pin_ufi_use_fast_fifo_out_reg
set var(SEQ_C2P_UFI_MODE)                                        pin_ufi_use_delay_fifo_out_reg
set var(SEQ_P2C_UFI_MODE)                                        pin_ufi_use_fast_fifo_out_reg
set var(ECC_C2P_UFI_MODE)                                        pin_ufi_use_delay_fifo_out_reg
set var(ECC_P2C_UFI_MODE)                                        pin_ufi_use_fast_fifo_out_reg
set var(LANE_C2P_UFI_MODE)                                       pin_ufi_use_delay_fifo_out_reg
set var(LANE_P2C_UFI_MODE)                                       pin_ufi_use_fast_fifo_out_reg
set var(PLL_NUM_OF_EXTRA_CLKS)                                   0
set var(PLL_C_CNT_LOW_3)                                         2
set var(PLL_C_CNT_HIGH_3)                                        2
set var(PLL_C_CNT_BYPASS_EN_3)                                   false
set var(PLL_C_CNT_PHASE_PS_STR_3)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_3)                                  50
set var(PLL_C_CNT_LOW_4)                                         2
set var(PLL_C_CNT_HIGH_4)                                        2
set var(PLL_C_CNT_BYPASS_EN_4)                                   false
set var(PLL_C_CNT_PHASE_PS_STR_4)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_4)                                  50
set var(PLL_C_CNT_LOW_5)                                         256
set var(PLL_C_CNT_HIGH_5)                                        256
set var(PLL_C_CNT_BYPASS_EN_5)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_5)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_5)                                  50
set var(PLL_C_CNT_LOW_6)                                         256
set var(PLL_C_CNT_HIGH_6)                                        256
set var(PLL_C_CNT_BYPASS_EN_6)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_6)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_6)                                  50
set var(PLL_C_CNT_LOW_7)                                         256
set var(PLL_C_CNT_HIGH_7)                                        256
set var(PLL_C_CNT_BYPASS_EN_7)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_7)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_7)                                  50
set var(PLL_C_CNT_LOW_8)                                         256
set var(PLL_C_CNT_HIGH_8)                                        256
set var(PLL_C_CNT_BYPASS_EN_8)                                   true
set var(PLL_C_CNT_PHASE_PS_STR_8)                                "0 ps"
set var(PLL_C_CNT_DUTY_CYCLE_8)                                  50

set var(C2P_SETUP_OC_NS)                                         0.000
set var(C2P_HOLD_OC_NS)                                          0.000
set var(P2C_SETUP_OC_NS)                                         0.000
set var(P2C_HOLD_OC_NS)                                          0.000
set var(C2C_SAME_CLK_SETUP_OC_NS)                                0.000
set var(C2C_SAME_CLK_HOLD_OC_NS)                                 0.000
set var(C2C_DIFF_CLK_SETUP_OC_NS)                                0.000
set var(C2C_DIFF_CLK_HOLD_OC_NS)                                 0.000
set var(C2C_TG_FALSE_PATH)                                       false
set var(C2P_P2C_PR)                                              false

set var(PATTERNS_AC_CLK)                                         [list arch|arch_inst|bufs_inst|gen_mem_ck.inst[0].b|cal_oct.obuf|o]
set var(PATTERNS_AC_CLK_N)                                       [list arch|arch_inst|bufs_inst|gen_mem_ck.inst[0].b|cal_oct.obuf_bar|o]
set var(PATTERNS_AC_SYNC)                                        [list arch|arch_inst|bufs_inst|gen_mem_a.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_a.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_act_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_ba.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_ba.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_bg.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cke.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_cs_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_odt.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_par.inst[0].b|cal_oct.obuf|o]
set var(PATTERNS_AC_ASYNC)                                       [list arch|arch_inst|bufs_inst|gen_mem_reset_n.inst[0].b|no_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_alert_n.inst[0].b|no_oct.ibuf|i]
set var(PATTERNS_RCLK)                                           [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_RCLK_N)                                         [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf_bar|o]
set var(PATTERNS_WCLK)                                           [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_WCLK_N)                                         [list arch|arch_inst|bufs_inst|gen_mem_dqs.inst[0].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[1].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[2].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[3].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[4].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[5].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[6].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[7].b|cal_oct.obuf_bar|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dqs.inst[8].b|cal_oct.obuf_bar|o]
set var(PATTERNS_RDATA)                                          [list arch|arch_inst|bufs_inst|gen_mem_dq.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[17].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[18].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[19].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[20].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[21].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[22].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[23].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[24].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[25].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[26].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[27].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[28].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[29].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[30].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[31].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[32].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[33].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[34].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[35].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[36].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[37].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[38].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[39].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[40].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[41].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[42].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[43].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[44].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[45].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[46].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[47].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[48].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[49].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[50].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[51].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[52].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[53].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[54].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[55].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[56].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[57].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[58].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[59].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[60].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[61].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[62].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[63].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[64].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[65].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[66].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[67].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[68].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[69].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[70].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[71].b|cal_oct.obuf|o]
set var(PATTERNS_WDATA)                                          [list arch|arch_inst|bufs_inst|gen_mem_dq.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[8].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[9].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[10].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[11].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[12].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[13].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[14].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[15].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[16].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[17].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[18].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[19].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[20].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[21].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[22].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[23].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[24].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[25].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[26].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[27].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[28].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[29].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[30].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[31].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[32].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[33].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[34].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[35].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[36].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[37].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[38].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[39].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[40].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[41].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[42].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[43].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[44].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[45].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[46].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[47].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[48].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[49].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[50].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[51].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[52].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[53].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[54].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[55].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[56].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[57].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[58].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[59].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[60].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[61].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[62].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[63].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[64].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[65].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[66].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[67].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[68].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[69].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[70].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dq.inst[71].b|cal_oct.obuf|o]
set var(PATTERNS_DM)                                             [list ]
set var(PATTERNS_DBI)                                            [list arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[0].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[1].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[2].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[3].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[4].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[5].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[6].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[7].b|cal_oct.obuf|o \
                                                                       arch|arch_inst|bufs_inst|gen_mem_dbi_n.inst[8].b|cal_oct.obuf|o]
set var(PATTERNS_ALERT_N)                                        [list arch|arch_inst|bufs_inst|gen_mem_alert_n.inst[0].b|no_oct.ibuf|i]

initialize_clock_uncertainty_data
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 55 emif_hps_altera_emif_arch_fm_191_ky5ybpi_parameters.tcl 1203 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the memory device and
# of the memory interface
# Note - this file is no longer used in Agilex and will be blank



 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 52 emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl 35672 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set script_dir [file dirname [info script]]
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_utils.tcl"

load_package sdc_ext

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_ddr_pins { instname allpins var_array_name} {
   # We need to make a local copy of the allpins associative array
   upvar allpins pins
   upvar 1 $var_array_name var
   set debug 0

   set var(pll_inclock_search_depth) 30
   set var(pll_outclock_search_depth) 20
   set var(pll_vcoclock_search_depth) 5

   # ########################################
   #  1.0 find all of the PLL output clocks


   set pll_c0_periph_clock_pin_name     "lvds_clk\[0\]"
   set pll_c1_periph_clock_pin_name     "loaden\[0\]"
   set vco_clock_pin_name               "vcoph\[0\]"

   #  C0 output in the periphery
   set pins(pll_c0_periph_clock) [list]
   set pins(pll_c0_periph_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$pll_c0_periph_clock_pin_name]]

   foreach_in_collection c $pins(pll_c0_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }
      lappend pins(pll_c0_periph_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(pll_c0_periph_clock) [emif_hps_altera_emif_arch_fm_191_ky5ybpi_sort_duplicate_names $pins(pll_c0_periph_clock)]

   #  C1 output in the periphery
   set pins(pll_c1_periph_clock) [list]
   set pins(pll_c1_periph_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$pll_c1_periph_clock_pin_name]]

   foreach_in_collection c $pins(pll_c1_periph_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }

      lappend pins(pll_c1_periph_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(pll_c1_periph_clock) [emif_hps_altera_emif_arch_fm_191_ky5ybpi_sort_duplicate_names $pins(pll_c1_periph_clock)]

   #  VCO clock (used for the system clock)
   set pins(vco_clock) [list]
   set pins(vco_clock_pin_id) [get_pins -nowarn [list ${instname}|arch|arch_inst|pll_inst|pll_inst*|$vco_clock_pin_name]]

   foreach_in_collection c $pins(vco_clock_pin_id) {
      set pin_info [get_pin_info -net $c]
      set net_name [get_net_info -name $pin_info]

      if {$debug} {
         puts "PLL pin -> PLL Net: [get_node_info -name $c] -> $net_name"
      }

      lappend pins(vco_clock) [regsub -all {\\} $net_name {\\\\}]
   }
   set pins(vco_clock) [emif_hps_altera_emif_arch_fm_191_ky5ybpi_sort_duplicate_names $pins(vco_clock)]
   set pins(pll_vco_clock) $pins(vco_clock)
   set pins(pll_phy_clock) $pins(pll_c1_periph_clock)
   set pins(pll_phy_clock_l) $pins(pll_c0_periph_clock)

   if {$debug == 1} {
     puts "VCO:           $pins(pll_vco_clock)"
     puts "PHY:           $pins(pll_phy_clock)"
     puts "PHY_L:         $pins(pll_phy_clock_l)"
     puts ""
   }

   #########################################
   # 2.0  Find the actual master core clock
   #      As it could come from another interface
   #      In master/slave configurations
   #
   # Skip this if we're in HPS mode as core clocks don't exist
   
   set pins(master_vco_clock) ""
   set pins(master_vco_clock_sec) ""
   set pins(master_core_usr_clock) ""
   set pins(master_core_usr_half_clock) ""
   set pins(master_core_usr_clock_sec) ""
   set pins(master_core_usr_half_clock_sec) ""
   set pins(master_core_afi_clock) ""
   set pins(master_core_dft_cpa_1_clock) ""
   set pins(master_cal_master_clk) ""
   set pins(master_cal_slave_clk) ""
   
   if {$var(IS_HPS)} {
      set pins(master_instname) $instname

   } else {
      set msg_list [ list ]

      set num_of_cpa_blocks [expr {$var(PHY_PING_PONG_EN) ? 2 : 1}]

      for {set cpa_idx 0} {$cpa_idx < $num_of_cpa_blocks} {incr cpa_idx} {

         if {$cpa_idx == 0} {
            set sync_reset_reg ${instname}|arch|arch_inst|non_hps.core_clks_rsts_inst|reset_sync_pri_sdc_anchor
         } else {
            set sync_reset_reg ${instname}|arch|arch_inst|non_hps.core_clks_rsts_inst|pp.reset_sync_sec_sdc_anchor
         }

         set core_reset_sync_clock "_UNDEFINED_PIN_"
         set core_reset_sync_clock_id [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_output_clock_id $sync_reset_reg "Usr clock" msg_list var]
         if {$core_reset_sync_clock_id == -1} {
            foreach {msg_type msg} $msg_list {
               post_message -type $msg_type "emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl: $msg"
            }
            post_message -type error "emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl: Failed to find clock source for register $sync_reset_reg"

            if {$var(PHY_CORE_CLKS_SHARING_ENUM) == "CORE_CLKS_SHARING_SLAVE"} {
               post_message -type error "emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl: This is a clock sharing SLAVE interface. Please ensure that the clks_sharing_master_out port of the master is connected to the clks_sharing_master_in port of the slave(s)."
               if {$cpa_idx > 0} {
                  post_message -type error "emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl: This clock sharing slave interface uses a Ping-Pong PHY and has extra clock/reset requirements. Please ensure that the master interface is also a ping-pong interface. A ping-pong interface can act as clock sharing master for both ping-pong and non-ping-pong interfaces."
               }
            } else {
               post_message -type error "emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl: Please ensure that the register has not been removed or optimized away."
            }
         } else {
            set core_reset_sync_clock [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_pll_clock_name $core_reset_sync_clock_id]
         }

         if {[regexp {(^.*)\|arch\|arch_inst\|io_tiles_wrap_inst\|io_tiles_inst\|tile_gen\[([0-9])\].tile_ctrl_inst(.*)\|pa_core_clk_out\[[0-9]\]$} $core_reset_sync_clock matched pins(master_instname) tilegen_num tile_instnum] == 1} {
            if {$var(PHY_CONFIG_ENUM) == "CONFIG_PHY_AND_HARD_CTRL"} {
               if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
                  if {$cpa_idx == 0} {
                     set pins(master_core_usr_clock)          "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                     set pins(master_core_usr_half_clock)     "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
                  } else {
                     set pins(master_core_usr_clock_sec)      "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                     set pins(master_core_usr_half_clock_sec) "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]"
                  }
               } else {
                  if {$cpa_idx == 0} {
                     set pins(master_core_usr_clock)          "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                  } else {
                     set pins(master_core_usr_clock_sec)      "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
                  }
               }
               set pins(master_core_dft_cpa_1_clock)   [expr {$var(DIAG_CPA_OUT_1_EN) ? "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[1\]" : ""}]

            } else {
               set pins(master_core_afi_clock)             "$pins(master_instname)|arch|arch_inst|io_tiles_wrap_inst|io_tiles_inst|tile_gen\[${tilegen_num}\].tile_ctrl_inst${tile_instnum}|pa_core_clk_out\[0\]"
            }

            if { $::TimeQuestInfo(nameofexecutable) == "quartus_map" || $::TimeQuestInfo(nameofexecutable) == "quartus_syn"} {
               set vco_clock_name "_UNDEFINED_PIN_"
            } else {
               set vco_clock_id [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_vco_clk_id $core_reset_sync_clock_id var]
               set vco_clock_name [get_net_info -name [get_pin_info -net $vco_clock_id]]
            }
            if {$cpa_idx == 0} {
               set pins(master_vco_clock) $vco_clock_name
            } else {
               set pins(master_vco_clock_sec) $vco_clock_name
            }

         } else {
            post_message -type error "emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl: Failed to find CPA outputs."
         }
      }

      if {!$var(DIAG_USE_CPA_LOCK)} {
         set pins(counter_lock_reg) $pins(master_instname)|arch|arch_inst|non_hps.core_clks_rsts_inst|counter_lock
      }

      set pll_master_user_clock_base [string range $pins(master_vco_clock) 0 [string last "|" $pins(master_vco_clock)] ]pll_inst|outclk

      set var(pll_c3_cnt) [emif_hps_altera_emif_arch_fm_191_ky5ybpi_calculate_counter_value $var(PLL_C_CNT_HIGH_3) $var(PLL_C_CNT_LOW_3) $var(PLL_C_CNT_BYPASS_EN_3)]
      set pins(master_cal_slave_clk) "$pll_master_user_clock_base\[3\]"

      set var(pll_c4_cnt) [emif_hps_altera_emif_arch_fm_191_ky5ybpi_calculate_counter_value $var(PLL_C_CNT_HIGH_4) $var(PLL_C_CNT_LOW_4) $var(PLL_C_CNT_BYPASS_EN_4)]
      set pins(master_cal_master_clk) "$pll_master_user_clock_base\[4\]"
   }

   if {$debug == 1} {
     puts "Master VCO                       : $pins(master_vco_clock)"
     puts "Master Core USR                  : $pins(master_core_usr_clock)"
     puts "Master Core USR Half             : $pins(master_core_usr_half_clock)"
     puts "Master Core AFI                  : $pins(master_core_afi_clock)"
     puts "Master VCO (SECONDARY)           : $pins(master_vco_clock_sec)"
     puts "Master Core USR (SECONDARY)      : $pins(master_core_usr_clock_sec)"
     puts "Master Core USR Half (SECONDARY) : $pins(master_core_usr_half_clock_sec)"
     puts ""
   }

   # ########################################
   #  2.5 Find the reference clock input of the PLL

   set pins(pll_cascade_in_id) [get_pins -nowarn -compatibility_mode $pins(master_instname)|arch|arch_inst|pll_inst|pll_inst|pll_cascade_in]
   if {[get_collection_size $pins(pll_cascade_in_id)] == 0} {
      set pins(pll_cascade_in_id) [get_pins -compatibility_mode $pins(master_instname)|arch|arch_inst|pll_inst|pll_inst|core_refclk]
   }
   set pll_ref_clock_id [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_input_clk_id $pins(pll_cascade_in_id) var]
   if {$pll_ref_clock_id == -1} {
      post_message -type critical_warning "emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl: Failed to find PLL reference clock"
   } else {
      set pll_ref_clock [get_node_info -name $pll_ref_clock_id]
   }
   set pins(pll_ref_clock) $pll_ref_clock

   if {$debug == 1} {
     puts "REF:     $pins(pll_ref_clock)"
     puts ""
   }

   #########################################
   # 3.0  find the FPGA pins

   # The hierarchy paths to all the pins are stored in the *_ip_parameters.tcl
   # file which is a generated file. Pins are divided into the following
   # protocol-agnostic categories. For each pin category, we need to
   # fully-resolve the hierarchy path patterns and store the results into
   # the "pins" arrays.

   set pin_categories [list ac_clk \
                            ac_clk_n \
                            ac_sync \
                            ac_async \
                            rclk \
                            rclk_n \
                            wclk \
                            wclk_n \
                            rdata \
                            wdata \
                            dm \
                            dbi ]

   set patterns [ list ]
   foreach pin_category $pin_categories {
      set pins($pin_category) [list]

      foreach pattern $var(PATTERNS_[string toupper $pin_category]) {
         set pattern "${instname}|$pattern"
         lappend patterns $pin_category $pattern
      }
   }

   foreach {pin_type pattern} $patterns {
      if {[string match "*|o" $pattern]} {
         set local_pins [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_names_in_collection [ get_fanouts $pattern ] ]
      } else {
         set local_pins [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_names_in_collection [ get_fanins $pattern ] ]
      }

      if {[llength $local_pins] == 0} {
         post_message -type critical_warning "Could not find pin of type $pin_type from pattern $pattern"
      } else {
         foreach pin [lsort -unique $local_pins] {
            lappend pins($pin_type) $pin
         }
      }
   }


   #########################################
   # 4.0  setup extra PLL clocks parameters

   # User can use remaining PLL clocks from EMIF GUI and this is to
   # setup the parameters for those clocks such as multiply_by
   # and divide_by

   if {$var(PLL_NUM_OF_EXTRA_CLKS) > 0} {

      set pll_master_user_clock_base [string range $pins(master_vco_clock) 0 [string last "|" $pins(master_vco_clock)] ]pll_inst|outclk

      set var(pll_num_of_reserved_cnts) 5

      for {set i 0} {$i < $var(PLL_NUM_OF_EXTRA_CLKS)} {incr i} {
         set i_cnt_num [expr $i + $var(pll_num_of_reserved_cnts)]
         set var(pll_c${i_cnt_num}_cnt) [emif_hps_altera_emif_arch_fm_191_ky5ybpi_calculate_counter_value $var(PLL_C_CNT_HIGH_${i_cnt_num}) $var(PLL_C_CNT_LOW_${i_cnt_num}) $var(PLL_C_CNT_BYPASS_EN_${i_cnt_num})]
         set pins(pll_extra_clk_${i}) "$pll_master_user_clock_base\[$i_cnt_num\]"
      }
   }
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_initialize_ddr_db { ddr_db_par var_array_name} {
   upvar $ddr_db_par local_ddr_db
   upvar 1 $var_array_name var

   global ::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename
   global ::io_only_analysis

   post_sdc_message info "Initializing DDR database for CORE $::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename"
   set instance_list [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_core_instance_list $::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename]

   foreach instname $instance_list {

      if {$::io_only_analysis == 0}  {
         post_sdc_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename INSTANCE: $instname"
         emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_ddr_pins $instname allpins var
         emif_hps_altera_emif_arch_fm_191_ky5ybpi_verify_ddr_pins allpins var
      }

      set local_ddr_db($instname) [ array get allpins ]
   }
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_verify_ddr_pins { pins_par var_array_name} {

   upvar 1 $var_array_name var
   upvar $pins_par pins

   if { [ llength $pins(pll_phy_clock) ] != [ llength $pins(pll_vco_clock) ] } {
      post_message -type critical_warning "Found different amounts of the phy_clocks compared to the vco_clocks"
   }
   if {!$var(IS_HPS)} {
      if {$var(PHY_CONFIG_ENUM) == "CONFIG_PHY_AND_HARD_CTRL"} {
         if { [ llength $pins(master_core_usr_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_usr_clock) ] of master_core_usr_clock when there should be 1"
         }

         if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
            if { [ llength $pins(master_core_usr_half_clock) ] != 1 } {
               post_message -type critical_warning "Found [ llength $pins(master_core_usr_half_clock) ] of master_core_usr_half_clock when there should be 1"
            }
         }

         if {$var(PHY_PING_PONG_EN)} {
            if { [ llength $pins(master_core_usr_clock_sec) ] != 1 } {
               post_message -type critical_warning "Found [ llength $pins(master_core_usr_clock_sec) ] of master_core_usr_clock_sec when there should be 1"
            }

            if {$var(USER_CLK_RATIO) == 2 && $var(C2P_P2C_CLK_RATIO) == 4} {
               if { [ llength $pins(master_core_usr_half_clock_sec) ] != 1 } {
                  post_message -type critical_warning "Found [ llength $pins(master_core_usr_half_clock_sec) ] of master_core_usr_half_clock_sec when there should be 1"
               }
            }
         }
      } else {
         if { [ llength $pins(master_core_afi_clock) ] != 1 } {
            post_message -type critical_warning "Found [ llength $pins(master_core_afi_clock) ] of master_core_afi_clock when there should be 1"
         }
      }
   }
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_all_instances_dqs_pins { ddr_db_par } {
   upvar $ddr_db_par local_ddr_db

   set dqs_pins [ list ]
   set instnames [ array names local_ddr_db ]
   foreach instance $instnames {
      array set pins $local_ddr_db($instance)

      foreach { dqs_pin } $pins(dqs_pins) {
         lappend dqs_pins ${dqs_pin}_IN
         lappend dqs_pins ${dqs_pin}_OUT
      }
      foreach { dqsn_pin } $pins(dqsn_pins) {
         lappend dqs_pins ${dqsn_pin}_OUT
      }
      foreach { ck_pin } $pins(ck_pins) {
         lappend dqs_pins $ck_pin
      }
   }

   return $dqs_pins
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_calculate_counter_value { cnt_hi cnt_lo cnt_bypass } {
   if {$cnt_bypass} {
      set result 1
   } else {
      set result [expr {$cnt_hi + $cnt_lo}]
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_input_clk_id { pll_inclk_id var_array_name} {
   upvar 1 $var_array_name var

   array set results_array [list]

   emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_fanin_up_to_depth $pll_inclk_id emif_hps_altera_emif_arch_fm_191_ky5ybpi_is_node_type_pin clock results_array $var(pll_inclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find PLL clock for [get_node_info -name $pll_inclk_id]"
      set result -1
   }

   return $result
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_output_clock_id { pin_list pin_type msg_list_name var_array_name} {
   upvar 1 $msg_list_name msg_list
   upvar 1 $var_array_name var
   set output_clock_id -1

   set output_id_list [list]
   set pin_collection [get_keepers -no_duplicates $pin_list]
   if {[get_collection_size $pin_collection] == [llength $pin_list]} {
      foreach_in_collection id $pin_collection {
         lappend output_id_list $id
      }
   } elseif {[get_collection_size $pin_collection] == 0} {
      lappend msg_list "warning" "Could not find any $pin_type pins"
   } else {
      lappend msg_list "warning" "Could not find all $pin_type pins"
   }
   emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_pll_clock $output_id_list $pin_type output_clock_id $var(pll_outclock_search_depth)
   return $output_clock_id
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_pll_clock { dest_id_list node_type clock_id_name search_depth} {
   if {$clock_id_name != ""} {
      upvar 1 $clock_id_name clock_id
   }
   set clock_id -1

   array set clk_array [list]
   foreach node_id $dest_id_list {
      emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_fanin_up_to_depth $node_id emif_hps_altera_emif_arch_fm_191_ky5ybpi_is_node_type_pll_clk clock clk_array $search_depth
   }
   if {[array size clk_array] == 1} {
      set clock_id [lindex [array names clk_array] 0]
      set clk [get_node_info -name $clock_id]
   } elseif {[array size clk_array] > 1} {
      puts "Found more than 1 clock driving the $node_type"
      set clk ""
   } else {
      set clk ""
   }

   return $clk
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_vco_clk_id { wf_clock_id var_array_name} {
   upvar 1 $var_array_name var

   array set results_array [list]

   emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_fanin_up_to_depth $wf_clock_id emif_hps_altera_emif_arch_fm_191_ky5ybpi_is_node_type_vco clock results_array $var(pll_vcoclock_search_depth)
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      post_message -type critical_warning "Could not find VCO clock for [get_node_info -name $wf_clock_id]"
      set result -1
   }

   return $result
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_is_node_type_pll_clk { node_id } {
   set cell_id [get_node_info -cell $node_id]

   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]

         if  {[regexp {pll_inst~.*OUTCLK[0-9]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } elseif {$atom_type == "TILE_CTRL"} {
         set node_name [get_node_info -name $node_id]

         if {[regexp {tile_ctrl_inst.*\|pa_core_clk_out\[[0-9]\]$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_is_node_type_vco { node_id } {
   set cell_id [get_node_info -cell $node_id]

   if {$cell_id == ""} {
      set result 0
   } else {
      set atom_type [get_cell_info -atom_type $cell_id]
      if {$atom_type == "IOPLL"} {
         set node_name [get_node_info -name $node_id]

         if {[regexp {pll_inst.*\|.*vcoph\[0\]$} $node_name]} {
            set result 1
         } elseif {[regexp {pll_inst.*VCOPH0$} $node_name]} {
            set result 1
         } else {
            set result 0
         }
      } else {
         set result 0
      }
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_does_ref_clk_exist { ref_clk_name } {

   set ref_clock_found 0
   foreach_in_collection iclk [get_clocks -nowarn] {
      if { ![is_clock_defined $iclk] } {
         continue
      }
      set clk_targets [get_clock_info -target $iclk]
      foreach_in_collection itgt $clk_targets {
         set node_name [get_node_info -name $itgt]
         if {[string compare $node_name $ref_clk_name] == 0} {
            set ref_clock_found 1
            break
         }
      }
      if {$ref_clock_found == 1} {
         break;
      }
   }

   return $ref_clock_found
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_p2c_c2p_clock_uncertainty { instname var_array_name } {

   set success 1
   set error_message ""
   set clock_uncertainty 0
   set debug 0

   package require ::quartus::atoms
   upvar 1 $var_array_name var

   catch {read_atom_netlist} read_atom_netlist_out
   set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]

   if {$read_atom_netlist_error == 0} {
      if {[emif_hps_altera_emif_arch_fm_191_ky5ybpi_are_entity_names_on]} {
         regsub -all {\|} $instname "|*:" instname
      }
      regsub -all {\\} $instname {\\\\} instname
      regsub -all {\[} $instname "\\\[" instname
      regsub -all {\]} $instname "\\\]" instname

      # Find the IOPLLs
      if {$success == 1} {
         if {[emif_hps_altera_emif_arch_fm_191_ky5ybpi_are_entity_names_on]} {
            set pll_atoms [get_atom_nodes -matching *${instname}|*:arch|*:arch_inst|*:pll_inst|* -type IOPLL]
         } else {
            set pll_atoms [get_atom_nodes -matching *${instname}|arch|arch_inst|pll_inst|* -type IOPLL]
         }
         set num_pll_inst [get_collection_size $pll_atoms]

         if {$num_pll_inst == 0} {
            set success 0
            post_message -type critical_warning "The auto-constraining script was not able to detect any PLLs in the < $instname > memory interface."
         }
      }

      # Get atom parameters
      if {$success == 1} {

         set mcnt_list [list]
         set bw_list   [list]
         set cp_setting_list [list]
         set vco_period_list [list]

         foreach_in_collection pll_atom $pll_atoms {

            # M-counter value
            if {[get_atom_node_info -node $pll_atom -key  BOOL_IOPLL_M_COUNTER_BYPASS_EN] == 1} {
               set mcnt 1
            } else {
               set mcnt [expr [get_atom_node_info -node $pll_atom -key INT_IOPLL_M_COUNTER_HIGH] + [get_atom_node_info -node $pll_atom -key INT_IOPLL_M_COUNTER_LOW]]
            }
            lappend mcnt_list $mcnt

            # BW
            set bw [get_atom_node_info -node $pll_atom -key  ENUM_IOPLL_BW_MODE]
            if {[string compare -nocase $bw "AUTO"] == 0} {
               set bw "LBW"
            } elseif  {[string compare -nocase $bw "LOW_BW"] == 0} {
                set bw "LBW"
            } elseif  {[string compare -nocase $bw "MID_BW"] == 0} {
                set bw "MBW"
            } elseif  {[string compare -nocase $bw "HI_BW"] == 0} {
                set bw "HBW"
            }
            lappend bw_list $bw

            # CP current setting (stubbed out for now as this is set internally)
            set cp_setting PLL_CP_SETTING0
            lappend cp_setting_list $cp_setting

            # VCO frequency setting
            set vco_period [get_atom_node_info -node $pll_atom -key TIME_IOPLL_VCO]
            lappend vco_period_list $vco_period
         }

         # Make sure all IOPLL parameters are the same
         for {set i [expr [llength $mcnt_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            if {[lindex $mcnt_list $i] != [lindex $mcnt_list [expr $i - 1]]} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $bw_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set bw_a [lindex $bw_list $i]
            set bw_b [lindex $bw_list [expr $i - 1]]
            if {[string compare -nocase $bw_a $bw_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
         for {set i [expr [llength $cp_setting_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set cp_a [lindex $cp_setting_list $i]
            set cp_b [lindex $cp_setting_list [expr $i - 1]]
            if {[string compare -nocase $cp_a $cp_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }

         for {set i [expr [llength $vco_period_list] - 1]} {$i > 0} {set i [expr $i - 1]} {
            set vco_a [lindex $vco_period_list $i]
            set vco_b [lindex $vco_period_list [expr $i - 1]]
            if {[string compare -nocase $vco_a $vco_b] != 0} {
               set success 0
               post_message -type critical_warning "The auto-constraining script found multiple PLLs in the < $instname > memory interface with different parameters."
            }
         }
      }

      # Calculate clock uncertainty
      if {$success == 1} {

         set mcnt [lindex $mcnt_list 0]
         set bw   [string toupper [lindex $bw_list 0]]
         set cp_setting [lindex $cp_setting_list 0]
         set cp_current [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_cp_current_from_setting $cp_setting]
         set vco_period [lindex $vco_period_list 0]
         if {[regexp {([0-9]+) ps} $vco_period matched vco_period] == 1} {
         } else {
            post_message -type critical_warning "The auto-constraining script was not able to read the netlist."
            set success 0
         }
         set vco_frequency_in_mhz [expr 1000000 / $vco_period]

         if {$debug} {
            puts "MCNT : $mcnt"
            puts "BW   : $bw"
            puts "CP   : $cp_setting ($cp_current)"
            puts "VCO  : $vco_period"
         }

         set HFR  [get_clock_frequency_uncertainty_data PLL $vco_frequency_in_mhz $bw OFFSET${mcnt} HFR]
         set LFD  [get_clock_frequency_uncertainty_data PLL $vco_frequency_in_mhz $bw OFFSET${mcnt} LFD]
         set SPE  [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_spe_from_cp_current $cp_current]

         if {$success == 1} {
            set clock_uncertainty_sqrt  [expr sqrt(($LFD/2)*($LFD/2) + ($LFD/2)*($LFD/2))]
            set clock_uncertainty [emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp [expr ($clock_uncertainty_sqrt + $SPE)*1e9]]

            if {$debug} {
               puts "HFR  : $HFR"
               puts "LFD  : $LFD"
               puts "SPE  : $SPE"
               puts "TOTAL: $clock_uncertainty"
            }
         }
      }

   } else {
      set success 0
      post_message -type critical_warning "The auto-constraining script was not able to read the netlist."
   }

   # Output warning in the case that clock uncertainty can't be determined
   if {$success == 0} {
      post_message -type critical_warning "Verify the following:"
      post_message -type critical_warning " The core < $instname > is instantiated within another component (wrapper)"
      post_message -type critical_warning " The core is not the top-level of the project"
      post_message -type critical_warning " The memory interface pins are exported to the top-level of the project"
      post_message -type critical_warning " The core  < $instname > RTL has not been modified manually"
   }

   return $clock_uncertainty
}


proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_cp_current_from_setting { cp_setting } {

   set cp_current 0

   if {[string compare -nocase $cp_setting "PLL_CP_SETTING0"] == 0} {
      set cp_current 0
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING1"] == 0} {
      set cp_current 5	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING2"] == 0} {
      set cp_current 10
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING3"] == 0} {
      set cp_current 15
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING4"] == 0} {
      set cp_current 20	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING5"] == 0} {
      set cp_current 25		
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING6"] == 0} {
      set cp_current 30
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING7"] == 0} {
      set cp_current 35	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING8"] == 0} {
      set cp_current 40	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING9"] == 0} {
      set cp_current 45
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING10"] == 0} {
      set cp_current 50	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING11"] == 0} {
      set cp_current 55			
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING12"] == 0} {
      set cp_current 60
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING13"] == 0} {
      set cp_current 65			
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING14"] == 0} {
      set cp_current 70	
   } elseif {[string compare -nocase $cp_setting "PLL_CP_SETTING15"] == 0} {
      set cp_current 75			
	} else {
      set cp_current 0
   }

   return $cp_current
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_spe_from_cp_current { cp_current } {

   set spe 158.0e-12

   if {$cp_current <= 15} {
      set spe 158e-012 
   } elseif {$cp_current <= 20} {
      set spe 130.62e-12 
   } elseif {$cp_current <= 25} {
      set spe 117.3e-12 
   } elseif {$cp_current <= 30} {
      set spe 109.5e-12 
   } elseif {$cp_current <= 35} {
      set spe 104.5e-12 
   } elseif {$cp_current <= 40} {
      set spe 100.9e-12 
   } elseif {$cp_current <= 60} {
      set spe 93.3e-12 
   } else {
      set spe 93.3e-12 
   }
   
   return $spe
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_periphery_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      set c2p_setup  0.050
      set c2p_hold   0.0
      set p2c_setup  0.050
      set p2c_hold   0.0
   } else {
      set c2p_setup  0.0
      set c2p_hold   0.0
      set p2c_setup  0.0
      set p2c_hold   0.0
   }

   set results [list $c2p_setup $c2p_hold $p2c_setup $p2c_hold]
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_core_clock_uncertainty { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set c2c_same_setup  0
   set c2c_same_hold   0
   set c2c_diff_setup  0
   set c2c_diff_hold   0

   set results [list $c2c_same_setup $c2c_same_hold $c2c_diff_setup $c2c_diff_hold]
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_core_overconstraints { results_array_name var_array_name } {
   upvar 1 $results_array_name results
   upvar 1 $var_array_name var

   set results [list $var(C2C_SAME_CLK_SETUP_OC_NS) $var(C2C_SAME_CLK_HOLD_OC_NS) $var(C2C_DIFF_CLK_SETUP_OC_NS) $var(C2C_DIFF_CLK_HOLD_OC_NS)]
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_periphery_overconstraints { results_st_array_name results_mt_array_name var_array_name } {
   upvar 1 $results_st_array_name results_st
   upvar 1 $results_mt_array_name results_mt
   upvar 1 $var_array_name var

   set c2p_p2c_frequency [expr $var(PHY_MEM_CLK_FREQ_MHZ)/$var(C2P_P2C_CLK_RATIO)]

   set results_st [list $var(C2P_SETUP_OC_NS) $var(C2P_HOLD_OC_NS) $var(P2C_SETUP_OC_NS) $var(P2C_HOLD_OC_NS)]
   set results_mt [list [expr $var(C2P_SETUP_OC_NS) + 0.000] [expr $var(C2P_HOLD_OC_NS) + 0.000] [expr $var(P2C_SETUP_OC_NS) + 0.000] [expr $var(P2C_HOLD_OC_NS) + 0.000]]

}


proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_sort_duplicate_names { names_array } {

   set main_name ""
   set duplicate_names [list]

   # Find the main name as opposed to all the duplicate names
   foreach { name } $names_array {
      if  {[regexp {Duplicate} $name]} {
         lappend duplicate_names $name
      } else {
         if {$main_name == ""} {
            set main_name $name
         } else {
            post_message -type error "More than one main tile name ($main_name and $name).  Please verify the connectivity of these pins."
         }
      }
   }

   # Now sort the duplicate names
   set duplicate_names [lsort -decreasing $duplicate_names]

   # Prepend the main name and then return
   set result [join [linsert $duplicate_names 0 $main_name]]

   return $result
}

 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 61 emif_hps_altera_emif_arch_fm_191_ky5ybpi_report_io_timing.tcl 8089 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the routines to generate the early external memory
# interface timing report at the before the start of the compile flow.
#
# These routines are only meant to be used in this specific context.
# Trying to using them in a different context can have unexpected
# results.
#
# In performing the above timing analysis, the script
# calls procedures that are found in a separate file (report_timing_core.tcl)
# that has all the details of the timing analysis, and this
# file only serves as the top-level timing analysis flow.
#
# To reduce data lookups in all the procuedures that perform
# the individual timing analysis, data that is needed for
# multiple procedures is lookup up in this file and passed
# to the various parameters.  These data include both values
# that are applicable over all operating conditions, and those
# that are applicable to only one operating condition.
#
#############################################################

# Determin if only doing IO analysis
set ::io_only_analysis 1

#############################################################
# Initialize the environment / Error Checking
#############################################################

if { ![info exists quartus(nameofexecutable)] || $quartus(nameofexecutable) != "quartus_sta" } {
   post_message -type error "This script must be run from quartus_sta"
   return 1
}

# Check the project
if { ! [ is_project_open ] } {
   if { [ llength $quartus(args) ] > 0 } {
      set project_name [lindex $quartus(args) 0]
      project_open -revision [ get_current_revision $project_name ] $project_name
   } else {
      post_message -type error "Missing project_name argument"
      return 1
   }
}


# Load the timing netlist if required
if { ! [timing_netlist_exist] } {
   # In IO only flow, check to see if we could even create a timing nelist
   # First try to see if we could even create a
   catch {create_timing_netlist} create_timing_netlist_out
   set create_timing_netlist_error [regexp "ERROR" $create_timing_netlist_out]

   # If create timing netlist cannot run, then the IO flow is a valid flow
   if {$create_timing_netlist_error == 1} {
      create_emif_netlist -revision $::quartus(project)
      sta_create_empty_report
   } else {
      delete_timing_netlist
      post_message -type error "Early EMIF IO timing estimate cannot be run once the Fitter has been run"
      return 1
   }

} else {
   post_message -type error "Early EMIF IO timing estimate cannot be run once the Fitter has been run"
   return 1
}

# Load the reports
load_package report
set current_timing_report_type [get_current_report_type]
if { [catch {load_report_database -type_name $current_timing_report_type} load_report_out ] } {
   create_report_database -type_name $current_timing_report_type
}

#############################################################
# Some useful functions
#############################################################
set script_dir [file dirname [info script]]
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_ip_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_report_timing_core.tcl"


if [ info exists ddr_db ] {
   unset ddr_db
}
emif_hps_altera_emif_arch_fm_191_ky5ybpi_initialize_ddr_db ddr_db var


# If multiple instances of this core are present in the
# design they will all be analyzed through the
# following loop
set instances [ array names ddr_db ]
set inst_id 0
foreach inst $instances {

   if { [ info exists pins ] } {
      # Clean-up stale content
      unset pins
   }
   array set pins $ddr_db($inst)

   #################################################################################
   # Find some design values and parameters that will used during the timing analysis
   # that do not change accross the operating conditions

   set fname ""
   set fbasename ""
   if {[llength $instances] <= 1} {
      set fbasename "${::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename}"
   } else {
      set fbasename "${::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename}_${inst_id}"
   }

   #################################################################################
   # Now loop the timing analysis over the various operating conditions
   set summary [list]

   set opcname "All conditions"
   set opcname [string trim $opcname]

   #######################################
   # PHY Analyses

   emif_hps_altera_emif_arch_fm_191_ky5ybpi_perform_core_analysis $opcname $inst pins var summary

   #######################################
   # Print out the Summary Panel for this instance

   set summary [lsort -command emif_hps_altera_emif_arch_fm_191_ky5ybpi_sort_proc $summary]

   post_message -type info "Core: ${::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename} - Instance: $inst"
   post_message -type info "                                                         setup  hold"
   set panel_name "[get_report_folder -relative]||$inst"
   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }

   # Create summary panel
   set total_failures 0
   set rows [list]
   lappend rows "add_row_to_table -id \$panel_id \[list \"Path\" \"Operating Condition\" \"Setup Slack\" \"Hold Slack\"\]"
   foreach summary_line $summary {
      foreach {corner order path su hold num_su num_hold} $summary_line { }
      if {($num_su == 0) || ([string trim $su] == "")} {
         set su "--"
      }
      if {($num_hold == 0) || ([string trim $hold] == "")} {
         set hold "--"
      }


      if { ($su != "--" && $su < 0) || ($hold != "--" && $hold < 0) } {
         incr total_failures
         set type warning
         set offset 50
      } else {
         set type info
         set offset 53
      }
      if {$su != "--"} {
         set su [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp $su]
      }
      if {$hold != "--"} {
         set hold [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp $hold]
      }
      post_message -type $type [format "%-${offset}s | %6s %6s" $path $su $hold]
      set fg_colours [list black black]
      if { $su != "--" && $su < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }

      if { $hold != "" && $hold < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }
      lappend rows "add_row_to_table -id \$panel_id -fcolors \"$fg_colours\" \[list \"$path\" \"$corner\" \"$su\" \"$hold\"\]"
   }
   if {$total_failures > 0} {
      post_message -type critical_warning "DDR Timing requirements not met"
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   foreach row $rows {
      eval $row
   }

   incr inst_id
}
# end foreach inst


 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 58 emif_hps_altera_emif_arch_fm_191_ky5ybpi_report_timing.tcl 10042 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the routines to generate the external memory
# interface timing report at the end of the compile flow.
#
# These routines are only meant to be used in this specific context.
# Trying to using them in a different context can have unexpected
# results.
#
# In performing the above timing analysis, the script
# calls procedures that are found in a separate file (report_timing_core.tcl)
# that has all the details of the timing analysis, and this
# file only serves as the top-level timing analysis flow.
#
# To reduce data lookups in all the procuedures that perform
# the individual timing analysis, data that is needed for
# multiple procedures is lookup up in this file and passed
# to the various parameters.  These data include both values
# that are applicable over all operating conditions, and those
# that are applicable to only one operating condition.
#
#############################################################

# Determine if only doing IO analysis
set ::io_only_analysis 0

#############################################################
# Initialize the environment / Error Checking
#############################################################

proc get_speedgrade_from_opn {part} {
   set temp_grade [get_part_info -temperature_grade $part]
   set speed_grade [get_part_info -speed_grade $part]
   set power_model [get_part_info -power_model $part]

   if {$temp_grade == "Extended"} {
      set temp_grade "E"
   } elseif {$temp_grade == "Industrial"} {
      set temp_grade "I"
   } elseif {$temp_grade == "Commercial"} {
      set temp_grade "C"
   } else {
      set temp_grade [string index $part 12]
   }

   if {$power_model == "{Standard Power}"} { 
      set power_model "V"
   } elseif {$power_model == "{Lower Power}"} {
      set power_model "E"
   } elseif {$power_model == "{Extreme Low Power}"} {
      set power_model "X"
   } elseif {$power_model == "{Fixed Voltage}"} {
      set power_model "F"
   } else {
      set power_model [string index $part 14]
   }

   set retval $temp_grade
   append retval $speed_grade
   append retval $power_model
   return $retval
}

if { ![info exists quartus(nameofexecutable)] || $quartus(nameofexecutable) != "quartus_sta" } {
   post_message -type error "This script must be run from quartus_sta"
   return 1
}

# Check the project
if { ! [ is_project_open ] } {
   if { [ llength $quartus(args) ] > 0 } {
		set project_name [lindex $quartus(args) 0]
		project_open -revision [ get_current_revision $project_name ] $project_name
	} else {
		post_message -type error "Missing project_name argument"
		return 1
	}
}


# Load the timing netlist if required
if { ! [timing_netlist_exist] } {
   create_timing_netlist
   read_sdc
   update_timing_netlist

   set script_dir [file dirname [info script]]
   source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_ip_parameters.tcl"
   source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_parameters.tcl"
   source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl"
   source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_report_timing_core.tcl"
   if { ! [timing_netlist_exist] } {
      post_message -type error "Timing Netlist has not been created. Run the 'Update Timing Netlist' task first."
      return 1
   }
}


# Load the atom netlist if required
load_package atoms
read_atom_netlist

# Load the reports
load_package report
set current_timing_report_type [get_current_report_type]
load_report_database -type_name $current_timing_report_type

#############################################################
# Some useful functions
#############################################################
set script_dir [file dirname [info script]]
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_ip_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_parameters.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_pin_map.tcl"
source "$script_dir/emif_hps_altera_emif_arch_fm_191_ky5ybpi_report_timing_core.tcl"

###############################################
# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to timing analyze the Core.

if [ info exists ddr_db ] {
   unset ddr_db
}
emif_hps_altera_emif_arch_fm_191_ky5ybpi_initialize_ddr_db ddr_db var

set old_active_clocks [get_active_clocks]
set_active_clocks [all_clocks]

# If multiple instances of this core are present in the
# design they will all be analyzed through the
# following loop
set instances [ array names ddr_db ]
set inst_id 0
foreach inst $instances {

   if { [ info exists pins ] } {
      # Clean-up stale content
      unset pins
   }
   array set pins $ddr_db($inst)

   #################################################################################
   # Find some design values and parameters that will used during the timing analysis
   # that do not change accross the operating conditions

   set fname ""
   set fbasename ""
   if {[llength $instances] <= 1} {
      set fbasename "${::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename}"
   } else {
      set fbasename "${::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename}_${inst_id}"
   }

   #################################################################################
   # Now loop the timing analysis over the various operating conditions
   set summary [list]

   set opcname [get_operating_conditions_info [get_operating_conditions] -display_name]
   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]
   set opcname [string trim $opcname]

   if {$hold_only_corner} {
      set opcname "${opcname}, Hold Only"
   }

   emif_hps_altera_emif_arch_fm_191_ky5ybpi_perform_core_analysis $opcname $inst pins var summary


   set summary [lsort -command emif_hps_altera_emif_arch_fm_191_ky5ybpi_sort_proc $summary]

   post_message -type info "Core: ${::GLOBAL_emif_hps_altera_emif_arch_fm_191_ky5ybpi_corename} - Instance: $inst"
   post_message -type info "                                                               setup  hold"
   set panel_name "[get_report_folder -relative]||$inst"
   # Delete any pre-existing summary panel
   set panel_id [get_report_panel_id $panel_name]
   if {$panel_id != -1} {
      delete_report_panel -id $panel_id
   }

   # Create summary panel
   set total_failures 0
   set rows [list]
   lappend rows "add_row_to_table -id \$panel_id \[list \"Path\" \"Operating Condition\" \"Setup Slack\" \"Hold Slack\"\]"
   foreach summary_line $summary {
      foreach {corner order path su hold num_su num_hold} $summary_line { }
      if {($num_su == 0) || ([string trim $su] == "")} {
         set su "--"
      }
      if {($num_hold == 0) || ([string trim $hold] == "")} {
         set hold "--"
      }

      set type info
      set offset 59

      if { ($su != "--" && $su < 0) || ($hold != "--" && $hold < 0) } {
         incr total_failures
      }
      if {$su != "--"} {
         set su [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp $su]
      }
      if {$hold != "--"} {
         set hold [ emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp $hold]
      }
      post_message -type $type [format "%-${offset}s | %6s %6s" $path $su $hold]
      set fg_colours [list black black]
      if { $su != "--" && $su < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }

      if { $hold != "" && $hold < 0 } {
         lappend fg_colours red
      } else {
         lappend fg_colours black
      }
      lappend rows "add_row_to_table -id \$panel_id -fcolors \"$fg_colours\" \[list \"$path\" \"$corner\" \"$su\" \"$hold\"\]"
   }
   if {$total_failures > 0} {
      post_message -type critical_warning "DDR Timing requirements not met"
      set panel_id [create_report_panel -table $panel_name -color red]
   } else {
      set panel_id [create_report_panel -table $panel_name]
   }
   foreach row $rows {
      eval $row
   }

   incr inst_id
}
# end foreach inst


set_active_clocks $old_active_clocks

set curr_part $::TimeQuestInfo(part)
set curr_speedgrade [get_speedgrade_from_opn $curr_part]

if {![test_part_trait_of $curr_part -trait FINAL_TIMING_MODEL]} {
   post_message -type critical_warning "Timing analysis was performed using a non-final timing model and/or constraints. You must regenerate the external memory interface IP and recheck timing closure in a future version of Quartus Prime."
}

if {$var(PHY_TARGET_SPEEDGRADE) == ""} {
   set effective_target_speedgrade "E1"
} else {
   set effective_target_speedgrade $var(PHY_TARGET_SPEEDGRADE)
}

if {$curr_speedgrade != $effective_target_speedgrade} {
   post_message -type critical_warning "This External Memory Interface IP core was generated for a speed grade $effective_target_speedgrade device, but the speed grade of $curr_part is $curr_speedgrade. You should regenerate the IP core to match the target device to avoid hardware issue."
}
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 63 emif_hps_altera_emif_arch_fm_191_ky5ybpi_report_timing_core.tcl 12487 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.




################################################################
# Helper function to add a report_timing-based analysis section
################################################################
proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_add_report_timing_analysis {opcname inst var_array_name summary_name title from_clks to_clks from_nodes to_nodes } {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var

   set num_failing_path 10

   set setup_margin    999.9
   set hold_margin     999.9
   set recovery_margin 999.9
   set removal_margin  999.9

   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -setup]] > 0)} {
      set res_0        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (setup)" -setup]
      set setup_margin [lindex $res_0 1]
   } else {
      set setup_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -hold]] > 0} {
      set res_1        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (hold)" -hold]
      set hold_margin  [lindex $res_1 1]
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title ($opcname)" $setup_margin $hold_margin]
   }

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -recovery]] > 0)} {
      set res_0           [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (recovery)" -recovery]
      set recovery_margin [lindex $res_0 1]
   } else {
      set recovery_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -removal]] > 0} {
      set res_1           [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name "$inst $title (removal)" -removal]
      set removal_margin  [lindex $res_1 1]
   } else {
      set removal_margin "--"
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title Recovery/Removal ($opcname)" $recovery_margin $removal_margin]
   }

   return [list $setup_margin $hold_margin $recovery_margin $removal_margin]
}

#############################################################
# Other Core-Logic related Timing Analysis
#############################################################

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_add_c2p_p2c_report_timing_analysis {opcname inst pin_array_name var_array_name summary_name title from_clks to_clks from_nodes to_nodes p2c} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins

   set num_failing_path 10

   set setup_margin    999.9
   set hold_margin     999.9
   set recovery_margin 999.9
   set removal_margin  999.9
   set debug 0

   set hold_only_corner [get_operating_conditions_info [get_operating_conditions] -is_hold_only]

   set positive_fcolour [list "black" "blue" "blue"]
   set negative_fcolour [list "black" "red"  "red"]
   set summary [list]

   # Get the periphery clocks
   if {$p2c} {
      set phyclks $from_clks
   } else {
      set phyclks $to_clks
   }

   # Set panel names
   set panel_name_setup  "$inst $title (setup)"
   set panel_name_hold   "$inst $title (hold)"
   set panel_name_recovery  "$inst $title (recovery)"
   set panel_name_removal   "$inst $title (removal)"	
   set disable_panel_color_flag ""
   set quiet_flag ""

   # Generate the default margins
   if {!$hold_only_corner} {
      set res_0        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_setup -setup $disable_panel_color_flag $quiet_flag]
      set setup_margin [lindex $res_0 1]
   } else {
      set setup_margin "--"
   }
   set res_1        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_hold -hold $disable_panel_color_flag $quiet_flag]
   set hold_margin  [lindex $res_1 1]

   set recovery_paths 0
   set removal_paths 0

   if {!$hold_only_corner && ([get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -recovery]] > 0)} {
      set recovery_paths 1
      set res_2        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_recovery -recovery $disable_panel_color_flag $quiet_flag]
      set recovery_margin [lindex $res_2 1]
   } else {
      set recovery_margin "--"
   }

   if {[get_collection_size [get_timing_paths -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths 1 -removal]] > 0} {
      set removal_paths 1
      set res_3        [report_timing -detail full_path -from_clock $from_clks -to_clock $to_clks -from $from_nodes -to $to_nodes -npaths $num_failing_path -panel_name $panel_name_removal  -removal  $disable_panel_color_flag $quiet_flag]
	   set removal_margin  [lindex $res_3 1]
   } else {
	   set removal_margin  "--"
   }

   if {$var(DIAG_TIMING_REGTEST_MODE)} {
      lappend global_summary [list $opcname 0 "$title ($opcname)" $setup_margin $hold_margin]
      if {($recovery_paths == 1) || ($removal_paths == 1)} {
         lappend global_summary [list $opcname 0 "$title Recovery/Removal ($opcname)" $recovery_margin $hold_margin]
      }
   }

   return [list $setup_margin $hold_margin $recovery_margin $removal_margin]
}


proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_perform_core_analysis {opcname inst pin_array_name var_array_name summary_name} {

   #######################################
   # Need access to global variables
   upvar 1 $summary_name global_summary
   upvar 1 $var_array_name var
   upvar 1 $pin_array_name pins
   global ::io_only_analysis

   # Debug switch. Change to 1 to get more run-time debug information
   set debug 0
   set result 1

   ###############################
   # PHY analysis
   ###############################

   set analysis_name "Core"

   if {$::io_only_analysis == 1} {
      set setup_slack "--"
      set hold_slack  "--"
      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_slack $hold_slack]
      post_message -type warning "Early EMIF IO timing estimate does not include core FPGA timing"
   } elseif {$var(IS_HPS)} {
      # No core timing analysis required by HPS interface
      set setup_slack "--"
      set hold_slack  "--"
      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_slack $hold_slack]
      lappend global_summary [list $opcname 0 "$analysis_name Recovery/Removal ($opcname)" $setup_slack $hold_slack]
   } else {

      set master_instname $pins(master_instname)
      set coreclkname [list ${master_instname}_core_usr_* ${master_instname}_core_afi_* ${master_instname}_core_dft_* ${master_instname}_ref_clock ${master_instname}_core_nios_clk [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_clock_name_from_pin_name $pins(pll_ref_clock)]]
      set coreclks [get_clocks -nowarn $coreclkname]

      set phyclkname [list ${inst}_phy_*]
      set phyclks [get_clocks -nowarn $phyclkname]

      set emif_regs [get_registers $inst|*]
      set rest_regs [remove_from_collection [all_registers] $emif_regs]

      set setup_margin    999.9
      set hold_margin     999.9
      set recovery_margin 999.9
      set removal_margin  999.9

      # Core/periphery transfers

      # Core-to-periphery
      set res [emif_hps_altera_emif_arch_fm_191_ky5ybpi_add_c2p_p2c_report_timing_analysis $opcname $inst $pin_array_name var global_summary "Core To Periphery" $coreclks $phyclks "*" $emif_regs 0]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Periphery-to-core
      set res [emif_hps_altera_emif_arch_fm_191_ky5ybpi_add_c2p_p2c_report_timing_analysis $opcname $inst $pin_array_name var global_summary "Periphery To Core" $phyclks $coreclks $emif_regs "*" 1]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Pure Core transfers

      set_active_clocks [remove_from_collection [all_clocks] $phyclks]

      # EMIF logic within FPGA core
      set res [emif_hps_altera_emif_arch_fm_191_ky5ybpi_add_report_timing_analysis $opcname $inst var global_summary "Within Core" $coreclks $coreclks $emif_regs $emif_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers between EMIF and user logic
      set res [emif_hps_altera_emif_arch_fm_191_ky5ybpi_add_report_timing_analysis $opcname $inst var global_summary "IP to User Logic" "*" "*" $emif_regs $rest_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers between user and EMIF logic
      set res [emif_hps_altera_emif_arch_fm_191_ky5ybpi_add_report_timing_analysis $opcname $inst var global_summary "User Logic to IP" "*" "*" $rest_regs $emif_regs]
      set setup_margin    [min $setup_margin    [lindex $res 0]]
      set hold_margin     [min $hold_margin     [lindex $res 1]]
      set recovery_margin [min $recovery_margin [lindex $res 2]]
      set removal_margin  [min $removal_margin  [lindex $res 3]]

      # Transfers within non-EMIF logic (not reported by default since they are irrelevant to EMIF IP)
      if {$var(DIAG_TIMING_REGTEST_MODE)} {
         set res [emif_hps_altera_emif_arch_fm_191_ky5ybpi_add_report_timing_analysis $opcname $inst var global_summary "Within User Logic" $coreclks $coreclks $rest_regs $rest_regs]
         set setup_margin    [min $setup_margin    [lindex $res 0]]
         set hold_margin     [min $hold_margin     [lindex $res 1]]
         set recovery_margin [min $recovery_margin [lindex $res 2]]
         set removal_margin  [min $removal_margin  [lindex $res 3]]
      }

      set_active_clocks [all_clocks]

      lappend global_summary [list $opcname 0 "$analysis_name ($opcname)" $setup_margin $hold_margin]
      lappend global_summary [list $opcname 0 "$analysis_name Recovery/Removal ($opcname)" $recovery_margin $removal_margin]
   }
}


 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 8 emif_hps 23 altera_emif_arch_fm_191 5 synth 50 emif_hps_altera_emif_arch_fm_191_ky5ybpi_utils.tcl 19177 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.



set script_dir [file dirname [info script]]

load_package sdc_ext
load_package design

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_index_in_collection { col j } {
   set i 0
   foreach_in_collection path $col {
      if {$i == $j} {
         return $path
      }
      set i [expr $i + 1]
   }
   return ""
}


proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_clock_to_pin_name_mapping {} {
   set result [list]
   set clocks_collection [get_clocks]
   foreach_in_collection clock $clocks_collection {
      if { ![is_clock_defined $clock] } {
         continue
      }
      set clock_name [get_clock_info -name $clock]
      set clock_target [get_clock_info -targets $clock]
      set first_index [emif_hps_altera_emif_arch_fm_191_ky5ybpi_index_in_collection $clock_target 0]
      set catch_exception_net [catch {get_net_info -name $first_index} pin_name_net]
      if {$catch_exception_net == 0} {
         lappend result [list $clock_name $pin_name_net]
      } else {
         set catch_exception_port [catch {get_port_info -name $first_index} pin_name_port]
         if {$catch_exception_port == 0} {
            lappend result [list $clock_name $pin_name_port]
         } else {
            set catch_exception_reg [catch {get_register_info -name $first_index} pin_name_reg]
            if {$catch_exception_reg == 0} {
               lappend result [list $clock_name $pin_name_reg]
            } else {
               set catch_exception_pin [catch {get_pin_info -name $first_index} pin_name_pin]
               if {$catch_exception_pin == 0} {
                  lappend result [list $clock_name $pin_name_pin]
               }
            }
         }
      }
   }
   return $result
}


proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_clock_name_from_pin_name { pin_name } {
   set table [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_clock_to_pin_name_mapping]
   foreach entry $table {
      if {[string compare [lindex [lindex [split $entry] 1] 0] $pin_name] == 0} {
         return [lindex $entry 0]
      }
   }
   return ""
}



proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_find_all_keepers { mystring } {
   set allkeepers [get_keepers $mystring ]

   foreach_in_collection keeper $allkeepers {
      set keepername [ get_node_info -name $keeper ]

      puts "$keepername"
   }
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_round_3dp { x } {
   return [expr { round($x * 1000) / 1000.0  } ]
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_current_timequest_report_folder {} {

   set catch_exception [catch {get_current_timequest_report_folder} error_message]
   if {[regexp ERROR $error_message] == 1} {
      return "ReportDDR"
   } else {
      return [get_current_timequest_report_folder]
   }
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_timequest_name {hier_name} {
   set sta_name $hier_name
   return $sta_name
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_are_entity_names_on { } {
   return [set_project_mode -is_show_entity]
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_core_instance_list {corename} {
   global ::io_only_analysis

   if {$::io_only_analysis == 1}  {
      set instance_list [list $corename]

   } else {
      set full_instance_list [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_core_full_instance_list $corename]
      set instance_list [list]

      foreach inst $full_instance_list {
         set sta_name [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_timequest_name $inst]
         if {[lsearch $instance_list [escape_brackets $sta_name]] == -1} {
            lappend instance_list $sta_name
         }
      }

   }
   return $instance_list
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_or_add_generated_clock {args} {
   array set opts [list -name "" -target "" -source "" -multiply_by 1 -divide_by 1 -phase 0]
   array set opts $args

   set multiply_by [expr int($opts(-multiply_by))]
   if {[expr $multiply_by - $opts(-multiply_by)] != 0.0} {
      post_message -type error "Specify an integer ranging from 0 to 99999999 for the option -multiply_by"
      return ""
   }

   set clock_name [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_clock_name_from_pin_name $opts(-target)]

   if {[string compare -nocase $clock_name ""] == 0} {
      set nets [get_nets $opts(-target) -nowarn]
      if {[get_collection_size $nets] > 0} {
         set pin_name [get_pin_info -name [get_net_info -pin $nets]]
         set clock_name [emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_clock_name_from_pin_name $pin_name]

         if {[string compare -nocase $clock_name ""] != 0} {
            if {[regexp -nocase "lvds_clk" $pin_name] || [regexp -nocase "loaden" $pin_name] } {
               remove_clock $clock_name
               set clock_name ""
            }
          }
       }
   } else {
      if {([string compare -nocase $opts(-name) ""] != 0) && ([string compare -nocase $opts(-name) $clock_name])} {

         if {[regexp -nocase "pll_inst\|outclk" $opts(-target)]} {
            remove_clock $clock_name
            set clock_name ""
         }
      }
   }

   if {[string compare -nocase $clock_name ""] == 0} {
      set clock_name $opts(-name)

      create_generated_clock \
         -name $clock_name \
         -source $opts(-source) \
         -multiply_by $multiply_by \
         -divide_by $opts(-divide_by) \
         -phase $opts(-phase) \
         $opts(-target)
   }

   return $clock_name
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_core_full_instance_list {corename} {

   set instance_list [list]

   if {[is_fitter_in_qhd_mode]} {
      set instance_list_pre [design::get_instances -entity $corename]

   } else {
      set instance_list_pre [get_entity_instances $corename]
   }

   foreach instance $instance_list_pre {
      regsub {\|arch$} $instance "" instance_no_arch
      lappend instance_list $instance_no_arch
   }

   if {[ llength $instance_list ] == 0} {
      post_message -type error "The auto-constraining script was not able to detect any instance for core < $corename >"
      post_message -type error "Make sure the core < $corename > is instantiated within another component (wrapper)"
      post_message -type error "and it's not the top-level for your project"
   }

   return $instance_list
}


proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
   upvar 1 $results_array_name results

   if {$depth < 0} {
      error "Internal error: Bad timing netlist search depth"
   }
   set fanin_edges [get_node_info -${edge_type}_edges $node_id]
   set number_of_fanin_edges [llength $fanin_edges]
   for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
      set fanin_edge [lindex $fanin_edges $i]
      set fanin_id [get_edge_info -src $fanin_edge]
      if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
         set results($fanin_id) 1
      } elseif {$depth == 0} {
      } else {
         emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
      }
   }
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_is_node_type_pin { node_id } {
   set node_type [get_node_info -type $node_id]
   if {$node_type == "port"} {
      set result 1
   } else {
      set result 0
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_pll_clock_name { clock_id } {
   set clock_name [get_node_info -name $clock_id]

   return $clock_name
}

proc post_sdc_message {msg_type msg} {
   global ::io_only_analysis

   if {($::io_only_analysis == 1) || $::TimeQuestInfo(nameofexecutable) != "quartus_fit"} {
      post_message -type $msg_type $msg
   }
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_names_in_collection { col } {
   set res [list]
   foreach_in_collection node $col {
      lappend res [ get_node_info -name $node ]
   }
   return $res
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_format_3dp { x } {
   return [format %.3f $x]
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_colours { x y } {

   set fcolour [list "black"]
   if {$x < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }
   if {$y < 0} {
      lappend fcolour "red"
   } else {
      lappend fcolour "blue"
   }

   return $fcolour
}

proc min { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a < $b } {
      return $a
   } else {
      return $b
   }
}

proc max { a b } {
   if { $a == "" } {
      return $b
   } elseif { $a > $b } {
      return $a
   } else {
      return $b
   }
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_max_in_collection { col attribute } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set max [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp > $max} {
            set max $temp
         }
      }
      set i [expr $i + 1]
   }
   return $max
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_min_in_collection { col attribute } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {$i == 0} {
         set min [get_path_info $path -${attribute}]
      } else {
         set temp [get_path_info $path -${attribute}]
         if {$temp < $min} {
            set min $temp
         }
      }
      set i [expr $i + 1]
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_min_in_collection_to_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -to_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_min_in_collection_from_clock { col attribute clock } {
   set i 0
   set min ERROR
   foreach_in_collection path $col {
      if {[get_clock_info -name [get_path_info $path -from_clock]] == $clock} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_min_in_collection_to_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_min_in_collection_from_name { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_max_in_collection_to_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -to]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_max_in_collection_from_name { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[get_node_info -name [get_path_info $path -from]] == $name} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}


proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_min_in_collection_to_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_min_in_collection_from_name2 { col attribute name } {
   set i 0
   set min 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set min [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp < $min} {
               set min $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $min
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_max_in_collection_to_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -to]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_max_in_collection_from_name2 { col attribute name } {
   set i 0
   set max 0
   foreach_in_collection path $col {
      if {[regexp $name [get_node_info -name [get_path_info $path -from]]]} {
         if {$i == 0} {
            set max [get_path_info $path -${attribute}]
         } else {
            set temp [get_path_info $path -${attribute}]
            if {$temp > $max} {
               set max $temp
            }
         }
         set i [expr $i + 1]
      }
   }
   return $max
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_sort_proc {a b} {
   set idxs [list 1 2 0]
   foreach i $idxs {
      set ai [lindex $a $i]
      set bi [lindex $b $i]
      if {$ai > $bi} {
         return 1
      } elseif { $ai < $bi } {
         return -1
      }
   }
   return 0
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_gcd {p q} {
   set p [expr {abs($p)}]
   set q [expr {abs($q)}]
   while {$q != 0} {
      set r [expr {$p % $q}]
      set p $q
      set q $r
   }
   return $p
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_atom_path {atom_id atom_oport_id path} {
   # Return list of {atom oterm_id} pairs by tracing the atom netlist starting from the given atom_id through the given path
   # Path consists of list of {atom_type fanin|fanout|end <port_type> <-optional>}
   set result [list]
   if {[llength $path] > 0} {
      set path_point [lindex $path 0]
      set atom_type [lindex $path_point 0]
      set next_direction [lindex $path_point 1]
      set port_type [lindex $path_point 2]
      set atom_optional [lindex $path_point 3]
      if {[get_atom_node_info -key type -node $atom_id] == $atom_type} {
         if {$next_direction == "end"} {
            if {[get_atom_port_info -key type -node $atom_id -port_id $atom_oport_id -type oport] == $port_type} {
               lappend result [list $atom_id $atom_oport_id]
            }
         } elseif {$next_direction == "atom"} {
            lappend result [list $atom_id]
         } elseif {$next_direction == "fanin"} {
            set atom_iport [get_atom_iport_by_type -node $atom_id -type $port_type]
            if {$atom_iport != -1} {
               set iport_fanin [get_atom_port_info -key fanin -node $atom_id -port_id $atom_iport -type iport]
               set source_atom [lindex $iport_fanin 0]
               set source_oterm [lindex $iport_fanin 1]
               set result [emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_atom_path $source_atom $source_oterm [lrange $path 1 end]]
            } elseif {$atom_optional == "-optional"} {
               set result [emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
            }
         } elseif {$next_direction == "fanout"} {
            set atom_oport [get_atom_oport_by_type -node $atom_id -type $port_type]
            if {$atom_oport != -1} {
               set oport_fanout [get_atom_port_info -key fanout -node $atom_id -port_id $atom_oport -type oport]
               foreach dest $oport_fanout {
                  set dest_atom [lindex $dest 0]
                  set dest_iterm [lindex $dest 1]
                  set fanout_result_list [emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_atom_path $dest_atom -1 [lrange $path 1 end]]
                  foreach fanout_result $fanout_result_list {
                     if {[lsearch $result $fanout_result] == -1} {
                        lappend result $fanout_result
                     }
                  }
               }
            }
         } else {
            error "Unexpected path"
         }
      } elseif {$atom_optional == "-optional"} {
         set result [emif_hps_altera_emif_arch_fm_191_ky5ybpi_traverse_atom_path $atom_id $atom_oport_id [lrange $path 1 end]]
      }
   }
   return $result
}

proc emif_hps_altera_emif_arch_fm_191_ky5ybpi_get_operating_conditions_number {} {
   set cur_operating_condition [get_operating_conditions]
   set counter 0
   foreach_in_collection op [get_available_operating_conditions] {
      if {[string compare $cur_operating_condition $op] == 0} {
         return $counter
      }
      incr counter
   }
   return $counter
}
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 8 qsys_top 18 user_rst_clkgate_0 32 altera_s10_user_rst_clkgate_1941 5 synth 34 altera_s10_user_rst_clkgate_fm.sdc 1177 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#Create base clock with 100 MHz targetted for internal clocks listed below

#Agilex
#auto_fab_0|alt_sld_fab_0|alt_sld_fab_0|agilexconfigreset|user_reset|sdm_gpo_out_user_reset~internal_ctrl_clock.reg


create_clock -name {internal_clk} -period 10.000 -waveform {0.000 5.000} { auto_fab*|*|*sdm_gpo_out_user_reset~internal_ctrl_clock }

set_clock_groups -asynchronous -group [get_clocks {internal_clk}]



 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 14 subsys_jtg_mst 6 fpga_m 28 altera_jtag_dc_streaming_191 5 synth 35 altera_avalon_st_jtag_interface.sdc 911 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 14 subsys_jtg_mst 6 fpga_m 28 altera_reset_controller_1921 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 14 subsys_jtg_mst 5 hps_m 28 altera_jtag_dc_streaming_191 5 synth 35 altera_avalon_st_jtag_interface.sdc 911 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set_false_path -from [get_registers *altera_jtag_src_crosser:*|sink_data_buffer*] -to [get_registers *altera_jtag_src_crosser:*|src_data*]
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 14 subsys_jtg_mst 5 hps_m 28 altera_reset_controller_1921 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 38 altera_eth_tse_ag_lvds_terminator_1950 5 synth 37 altera_eth_tse_ag_lvds_terminator.sdc 2910 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


set old_mode [set_project_mode -get_mode_value always_show_entity_name] 
set_project_mode -always_show_entity_name on

# Function to constraint pointers for DCFIFO
proc alt_tse_dcfifo_constraint_ptr {from_path from_reg to_path to_reg max_skew max_net_delay} {
    
    if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
        # Check for instances
        set inst [get_registers -nowarn *${from_path}|${from_reg}\[0\]]
        
        # Check number of instances
        set inst_num [llength [query_collection -report -all $inst]]
        
        # Constraint one instance at a time to avoid set_max_skew apply to all instances
        foreach_in_collection each_inst_tmp $inst {
            set each_inst [get_node_info -name $each_inst_tmp]
            
            # Get the path to instance
            regexp "(.*${from_path})(.*|)(${from_reg})" $each_inst reg_path inst_path inst_name reg_name
            
            set_max_skew -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] $max_skew
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] 200ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] -200ns
        }
        
    } else {
        set_net_delay -from [get_pins -compatibility_mode *${from_path}|${from_reg}[*]|q] -to [get_registers *${to_path}|${to_reg}*] -max $max_net_delay
        
        # Relax the fitter effort
        set_max_delay -from [get_registers *${from_path}|${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] 200ns
        set_min_delay -from [get_registers *${from_path}|${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] -200ns
        
    }
    
}

# add constraint for DCFIFO
alt_tse_dcfifo_constraint_ptr tx_dc_fifo*|async_fifo|dcfifo_componenet|auto_generated  rdptr_g          tx_dc_fifo*|async_fifo|dcfifo_componenet|auto_generated|ws_dgrp|dffpipe*  dffe  7.5ns  6ns

set_project_mode -always_show_entity_name $old_mode
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 35 altera_eth_tse_pcs_pma_nf_lvds_1950 5 synth 34 altera_eth_tse_pcs_pma_nf_lvds.sdc 11760 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# CORE_PARAMETERS
set IS_SGMII 1
set CONNECT_TO_MAC 0
set IS_INT_FIFO 1
set IS_HD_LOGIC 1
set ENABLE_REV_LOOPBACK 0
set ENABLE_TIMESTAMPING 0

set old_mode [set_project_mode -get_mode_value always_show_entity_name] 
set_project_mode -always_show_entity_name on

# Function to constraint non-std_synchronizer path
proc altera_eth_tse_constraint_net_delay {from_reg to_reg max_net_delay} {
   
   set_net_delay -from [get_pins -compatibility_mode ${from_reg}|q] -to [get_registers ${to_reg}] -max $max_net_delay
   
   if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
      set_max_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] 100ns
      set_min_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] -100ns
   } else {
      # Relax the fitter effort
      set_max_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] 8ns
      set_min_delay -from [get_registers ${from_reg}] -to [get_registers ${to_reg}] -100ns
   }
   
}

# Function to constraint std_synchronizer
proc altera_eth_tse_constraint_std_sync {} {
   
   altera_eth_tse_constraint_net_delay  *  *altera_eth_tse_std_synchronizer:*|altera_std_synchronizer_nocut:*|din_s1  6ns
   
}

# Function to constraint pointers
proc altera_eth_tse_constraint_ptr {from_path from_reg to_path to_reg max_skew max_net_delay} {
   
   set_net_delay -from [get_pins -compatibility_mode *${from_path}|${from_reg}[*]|q] -to [get_registers *${to_path}|${to_reg}*] -max $max_net_delay
   
   if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
      # Check for instances
      set inst [get_registers -nowarn *${from_path}|${from_reg}\[0\]]
      
      # Check number of instances
      set inst_num [llength [query_collection -report -all $inst]]
      if {$inst_num > 0} {
         # Uncomment line below for debug purpose
         #puts "${inst_num} ${from_path}|${from_reg} instance(s) found"
      } else {
         # Uncomment line below for debug purpose
         #puts "No ${from_path}|${from_reg} instance found"
      }
      
      # Constraint one instance at a time to avoid set_max_skew apply to all instances
      foreach_in_collection each_inst_tmp $inst {
      set each_inst [get_node_info -name $each_inst_tmp] 
         # Get the path to instance
         regexp "(.*${from_path})(.*|)(${from_reg})" $each_inst reg_path inst_path inst_name reg_name
         
         set_max_skew -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] $max_skew
         
         set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] 100ns
         set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] -100ns
      }
      
   } else {
      # Relax the fitter effort
      set_max_delay -from [get_registers *${from_path}|${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] 8ns
      set_min_delay -from [get_registers *${from_path}|${from_reg}[*]] -to [get_registers *${to_path}|${to_reg}*] -100ns
   }
   
}

# Function to constraint clock crosser
proc altera_eth_tse_constraint_clock_crosser {} {
    set module_name altera_tse_clock_crosser
    
    set from_reg1 in_data_toggle
    set to_reg1 altera_eth_tse_std_synchronizer:in_to_out_synchronizer|altera_std_synchronizer_nocut:*|din_s1
    
    set from_reg2 in_data_buffer
    set to_reg2 out_data_buffer
    
    set from_reg3 out_data_toggle_flopped
    set to_reg3 altera_eth_tse_std_synchronizer:out_to_in_synchronizer|altera_std_synchronizer_nocut:*|din_s1
    
    set max_skew 7.5ns
    
    set max_delay1 6ns
    set max_delay2 4ns
    set max_delay3 6ns
    
    set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg1}|q]    -to [get_registers *${module_name}:*|${to_reg1}] -max $max_delay1
    set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg2}[*]|q] -to [get_registers *${module_name}:*|${to_reg2}[*]] -max $max_delay2
    set_net_delay -from [get_pins -compatibility_mode *${module_name}:*|${from_reg3}|q]    -to [get_registers *${module_name}:*|${to_reg3}] -max $max_delay3
    
    if { [string equal "quartus_sta" $::TimeQuestInfo(nameofexecutable)] } {
        # Check for instances
        set inst [get_registers -nowarn *${module_name}:*|${from_reg1}]
        
        # Check number of instances
        set inst_num [llength [query_collection -report -all $inst]]
        if {$inst_num > 0} {
            # Uncomment line below for debug purpose
            #puts "${inst_num} ${module_name} instance(s) found"
        } else {
            # Uncomment line below for debug purpose
            #puts "No ${module_name} instance found"
        }
        
        # Constraint one instance at a time to avoid set_max_skew apply to all instances
        foreach_in_collection each_inst_tmp $inst {
        set each_inst [get_node_info -name $each_inst_tmp] 
            # Get the path to instance
            regexp "(.*${module_name})(:.*|)(${from_reg1})" $each_inst reg_path inst_path inst_name reg_name
            
            # Check if unused data buffer get synthesized away
            set reg2_collection [get_registers -nowarn ${inst_path}${inst_name}${to_reg2}[*]]
            set reg2_num [llength [query_collection -report -all $reg2_collection]]
            
            if {$reg2_num > 0} {
                set_max_skew -from [get_registers "${inst_path}${inst_name}${from_reg1} ${inst_path}${inst_name}${from_reg2}[*]"] -to [get_registers "${inst_path}${inst_name}${to_reg1} ${inst_path}${inst_name}${to_reg2}[*]"] $max_skew
                
                set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg2}[*]] -to [get_registers ${inst_path}${inst_name}${to_reg2}[*]] 100ns
                set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg2}[*]] -to [get_registers ${inst_path}${inst_name}${to_reg2}[*]] -100ns
            }
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg1}] -to [get_registers ${inst_path}${inst_name}${to_reg1}] 100ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg1}] -to [get_registers ${inst_path}${inst_name}${to_reg1}] -100ns
            
            set_max_delay -from [get_registers ${inst_path}${inst_name}${from_reg3}] -to [get_registers ${inst_path}${inst_name}${to_reg3}] 100ns
            set_min_delay -from [get_registers ${inst_path}${inst_name}${from_reg3}] -to [get_registers ${inst_path}${inst_name}${to_reg3}] -100ns
        }
        
    } else {
        # Relax the fitter effort
        set_max_delay -from [get_registers *${module_name}:*|${from_reg1}]    -to [get_registers *${module_name}:*|${to_reg1}] 8ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg1}]    -to [get_registers *${module_name}:*|${to_reg1}] -100ns
        
        set_max_delay -from [get_registers *${module_name}:*|${from_reg2}[*]] -to [get_registers *${module_name}:*|${to_reg2}[*]] 8ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg2}[*]] -to [get_registers *${module_name}:*|${to_reg2}[*]] -100ns
        
        set_max_delay -from [get_registers *${module_name}:*|${from_reg3}]    -to [get_registers *${module_name}:*|${to_reg3}] 8ns
        set_min_delay -from [get_registers *${module_name}:*|${from_reg3}]    -to [get_registers *${module_name}:*|${to_reg3}] -100ns
    }
    
}

# Constraint Standard Synchronizer
altera_eth_tse_constraint_std_sync

if { [ expr ($IS_SGMII == 1)] } {

    altera_eth_tse_constraint_ptr  altera_tse_a_fifo_24:*|altera_tse_gray_cnt:U_RD  g_out  altera_tse_a_fifo_24:*altera_std_synchronizer_nocut:*  din_s1  7.5ns  6ns
    altera_eth_tse_constraint_ptr  altera_tse_a_fifo_24:*|altera_tse_gray_cnt:U_WRT  g_out  altera_tse_a_fifo_24:*altera_std_synchronizer_nocut:*  din_s1  7.5ns  6ns

	if {[expr ($CONNECT_TO_MAC == 1)]} {
	  if {[expr ($IS_INT_FIFO == 0)]} {
		  if {[expr ($IS_HD_LOGIC == 1)]} {
			 altera_eth_tse_constraint_net_delay  *altera_tse_top_sgmii*:U_SGMII|altera_tse_colision_detect:U_COL|state*  *altera_tse_fifoless_mac_tx:U_TX|gm_rx_col_reg*  6ns
		  }
	  }
	}	
} else {
   if {[expr ($ENABLE_REV_LOOPBACK == 1)]} {
      altera_eth_tse_constraint_ptr  altera_tse_a_fifo_24:*|altera_tse_gray_cnt:U_RD  g_out  altera_tse_a_fifo_24:*altera_std_synchronizer_nocut:*  din_s1  7.5ns  6ns
      altera_eth_tse_constraint_ptr  altera_tse_a_fifo_24:*|altera_tse_gray_cnt:U_WRT  g_out  altera_tse_a_fifo_24:*altera_std_synchronizer_nocut:*  din_s1  7.5ns  6ns
   }
}

if {[expr ($ENABLE_TIMESTAMPING == 1)]} {
   set regs [get_registers -nowarn *altera_tse_ph_calculator:*|altera_eth_tse_ptp_std_synchronizer:U_SYNC_WR_PTR|altera_std_synchronizer_nocut:*|din_s1]
   if {[llength [query_collection -report -all $regs]] > 0} {
      altera_eth_tse_constraint_ptr  altera_tse_ph_calculator:phase_calculator.ph_cal_inst  wr_ptr_sample  altera_tse_ph_calculator:*|altera_eth_tse_ptp_std_synchronizer:U_SYNC_WR_PTR|altera_std_synchronizer_nocut:*  din_s1  4.5ns  3ns
   }

   set regs [get_registers -nowarn *altera_tse_ph_calculator:*|altera_eth_tse_ptp_std_synchronizer:U_SYNC_RD_PTR|altera_std_synchronizer_nocut:*|din_s1]
   if {[llength [query_collection -report -all $regs]] > 0} {
      altera_eth_tse_constraint_ptr  altera_tse_ph_calculator:phase_calculator.ph_cal_inst  rd_ptr_sample  altera_tse_ph_calculator:*|altera_eth_tse_ptp_std_synchronizer:U_SYNC_RD_PTR|altera_std_synchronizer_nocut:*  din_s1  4.5ns  3ns
   }
}

# Clock Crosser
altera_eth_tse_constraint_clock_crosser

# False path marker used in auto negotiation module
altera_eth_tse_constraint_net_delay  *  *altera_tse_false_path_marker:*|data_out_reg*  6ns

#**************************************************************
# Set False Path for altera_tse_reset_synchronizer
#**************************************************************
set tse_aclr_counter 0
set tse_clrn_counter 0
set tse_aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|altera_tse_reset_synchronizer:*|altera_tse_reset_synchronizer_chain*|aclr]
set tse_clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|altera_tse_reset_synchronizer:*|altera_tse_reset_synchronizer_chain*|clrn]
foreach_in_collection tse_aclr_pin $tse_aclr_collection {
   set tse_aclr_counter [expr $tse_aclr_counter + 1]
}
foreach_in_collection tse_clrn_pin $tse_clrn_collection {
   set tse_clrn_counter [expr $tse_clrn_counter + 1]
}
if {$tse_aclr_counter > 0} {
   set_false_path -to [get_pins -compatibility_mode -nocase *|altera_tse_reset_synchronizer:*|altera_tse_reset_synchronizer_chain*|aclr]
}

if {$tse_clrn_counter > 0} {
   set_false_path -to [get_pins -compatibility_mode -nocase *|altera_tse_reset_synchronizer:*|altera_tse_reset_synchronizer_chain*|clrn]
}

set_project_mode -always_show_entity_name $old_mode
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 17 altera_iopll_1931 5 synth 39 eth_tse_0_altera_iopll_1931_c6qpzfa.sdc 5698 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the timing constraints for the Altera PLL.
#    * The helper routines are defined in eth_tse_0_altera_iopll_1931_c6qpzfa_pin_map.tcl
#
# NOTE
# ----
# Debug switch. Change to 1 to get more run-time debug information
set debug 0

set script_dir [file dirname [info script]]

source "$script_dir/eth_tse_0_altera_iopll_1931_c6qpzfa_parameters.tcl"
source "$script_dir/eth_tse_0_altera_iopll_1931_c6qpzfa_pin_map.tcl"

####################
#                  #
# GENERAL SETTINGS #
#                  #
####################

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty


# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ ai_are_entity_names_on ]

if {[catch {load_package atoms
            load_package sdc_ext
            load_package design
            catch {read_atom_netlist} read_atom_netlist_out
            set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]
            } err_loading_packages]} {
    post_message -type error "Failed to load packages required by IOPLL SDC: $err_loading_packages"
}

# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to apply timing constraints.
# During the fitter, the routines will be called only once
# and cached data will be used in all subsequent calls.



if {[info exists ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_ai_pll_db]} {
    # Clean-up stale content
    unset ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_ai_pll_db
}
if {[catch {ai_initialize_pll_db ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_ai_pll_db} err_initializing_db]} {
    post_message -type warning "Failed to find atom information in IOPLL SDC: $err_initializing_db"
}

# If multiple instances of this core are present in the
# design they will all be constrained through the
# following loop
set instances [ array names ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_ai_pll_db ]
foreach { inst } $instances {
	if { [ info exists pins ] } {
		# Clean-up stale content
		unset pins
	}
	
	# -------------------------------- #
	# -                              - #
	# --- Determine PLL Parameters --- #
	# -                              - #
	# -------------------------------- #
	
	set pll_atoms [get_atom_nodes -matching ${inst}* -type IOPLL]
	set num_pll_inst [get_collection_size $pll_atoms]
	
	if {$num_pll_inst > 1} { 
		# Error condition
		post_message -type error "SDC: More than one PLL atom found with instance name $inst"
	} else {
		# Use IP generated parameters
		if { $debug } {
			post_message -type info "SDC: using IP generated parameter values"
		}
	}

    # These dictionaries hold all the clock information.
    lassign $::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_ai_pll_db($inst) base_clock_data_dict gen_clock_data_dict
	
	# ------------------------ #
	# -                      - #
	# ---REFERENCE CLOCK(s)--- #
	# -                      - #
	# ------------------------ #
    dict for {clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_fpga_pin && !$exists} {
               create_clock -period $period \
                   -waveform [ list 0 $half_period] \
                   -name $name $port_node_name
            }
        }
    }
	# ------------------------- #
	# -                       - #
	# --- OUTPUT PLL CLOCKS --- #
	# -                       - #
	# ------------------------- #
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            if {$is_valid && !$exists} {
                create_generated_clock -add \
                    -source $src \
                    -name $name \
                    -multiply_by $multiply_by \
                    -divide_by $divide_by \
                    -phase $phase \
                    -duty_cycle $duty_cycle \
                    $pin_node_name
                
                if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {  
                    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                } 
            }
        }
    }

    foreach_in_collection node [get_nodes -no_duplicates -nowarn "${inst}|tennm_pll|dprio_rst_n"] {
        set_false_path -through [get_node_info -name $node]
    }
}
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 17 altera_iopll_1931 5 synth 53 eth_tse_0_altera_iopll_1931_c6qpzfa_all_ip_params.tcl 51523 # PLL parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!

set ::pll_corename eth_tse_0_altera_iopll_1931_c6qpzfa

set ::pll_all_ip_params [dict create]

dict set ::pll_all_ip_params gui_device_family "Agilex"
dict set ::pll_all_ip_params gui_device_component "AGFB014R24B2E2V"
dict set ::pll_all_ip_params gui_device_speed_grade "2"
dict set ::pll_all_ip_params gui_device_iobank_rev "IO96A_REVB2"
dict set ::pll_all_ip_params gui_debug_mode "false"
dict set ::pll_all_ip_params gui_skip_sdc_generation "false"
dict set ::pll_all_ip_params gui_include_iossm "false"
dict set ::pll_all_ip_params gui_cal_code_hex_file "iossm.hex"
dict set ::pll_all_ip_params gui_parameter_table_hex_file "seq_params_sim.hex"
dict set ::pll_all_ip_params gui_pll_tclk_mux_en "false"
dict set ::pll_all_ip_params gui_pll_tclk_sel "pll_tclk_m_src"
dict set ::pll_all_ip_params gui_pll_vco_freq_band_0 "pll_freq_clk0_band18"
dict set ::pll_all_ip_params gui_pll_vco_freq_band_1 "pll_freq_clk1_band18"
dict set ::pll_all_ip_params gui_pll_freqcal_en "true"
dict set ::pll_all_ip_params gui_pll_freqcal_req_flag "true"
dict set ::pll_all_ip_params gui_cal_converge "false"
dict set ::pll_all_ip_params gui_cal_error "cal_clean"
dict set ::pll_all_ip_params gui_pll_cal_done "false"
dict set ::pll_all_ip_params gui_pll_type "S10_Simple"
dict set ::pll_all_ip_params gui_pll_m_cnt_in_src "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src0 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src1 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src2 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src3 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src4 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src5 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src6 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src7 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src8 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params system_info_device_family "Agilex"
dict set ::pll_all_ip_params system_info_device_component "AGFB014R24B2E2V"
dict set ::pll_all_ip_params system_info_device_speed_grade "2"
dict set ::pll_all_ip_params system_part_trait_speed_grade "2"
dict set ::pll_all_ip_params system_part_trait_iobank_rev "IO96A_REVB2"
dict set ::pll_all_ip_params gui_usr_device_speed_grade "1"
dict set ::pll_all_ip_params gui_en_reconf "false"
dict set ::pll_all_ip_params gui_en_iossm_reconf "false"
dict set ::pll_all_ip_params gui_en_dps_ports "false"
dict set ::pll_all_ip_params gui_pll_mode "Integer-N PLL"
dict set ::pll_all_ip_params gui_location_type "I/O Bank"
dict set ::pll_all_ip_params gui_use_logical "false"
dict set ::pll_all_ip_params gui_reference_clock_frequency "125.0"
dict set ::pll_all_ip_params gui_reference_clock_frequency_ps "10000.0"
dict set ::pll_all_ip_params gui_use_coreclk "false"
dict set ::pll_all_ip_params gui_refclk_might_change "false"
dict set ::pll_all_ip_params gui_fractional_cout "32"
dict set ::pll_all_ip_params gui_prot_mode "UNUSED"
dict set ::pll_all_ip_params gui_dsm_out_sel "1st_order"
dict set ::pll_all_ip_params gui_use_locked "true"
dict set ::pll_all_ip_params gui_en_adv_params "false"
dict set ::pll_all_ip_params gui_pll_bandwidth_preset "High"
dict set ::pll_all_ip_params gui_lock_setting "Low Lock Time"
dict set ::pll_all_ip_params gui_pll_auto_reset "false"
dict set ::pll_all_ip_params gui_en_lvds_ports "Enable LVDS_CLK/LOADEN 0 & 1"
dict set ::pll_all_ip_params gui_en_periphery_ports "false"
dict set ::pll_all_ip_params gui_operation_mode "direct"
dict set ::pll_all_ip_params gui_feedback_clock "Global Clock"
dict set ::pll_all_ip_params gui_clock_to_compensate "0"
dict set ::pll_all_ip_params gui_use_NDFB_modes "false"
dict set ::pll_all_ip_params gui_refclk_switch "false"
dict set ::pll_all_ip_params gui_refclk1_frequency "100.0"
dict set ::pll_all_ip_params gui_en_phout_ports "true"
dict set ::pll_all_ip_params gui_phout_division "1"
dict set ::pll_all_ip_params gui_en_extclkout_ports "false"
dict set ::pll_all_ip_params gui_number_of_clocks "5"
dict set ::pll_all_ip_params gui_multiply_factor "6"
dict set ::pll_all_ip_params gui_divide_factor_n "1"
dict set ::pll_all_ip_params gui_frac_multiply_factor "1"
dict set ::pll_all_ip_params gui_fix_vco_frequency "true"
dict set ::pll_all_ip_params gui_fixed_vco_frequency "1250.0"
dict set ::pll_all_ip_params gui_fixed_vco_frequency_ps "1667.0"
dict set ::pll_all_ip_params gui_vco_frequency "600.0"
dict set ::pll_all_ip_params gui_enable_output_counter_cascading "false"
dict set ::pll_all_ip_params gui_mif_gen_options "Generate New MIF File"
dict set ::pll_all_ip_params gui_new_mif_file_path "~/pll.mif"
dict set ::pll_all_ip_params gui_existing_mif_file_path "~/pll.mif"
dict set ::pll_all_ip_params gui_mif_config_name "unnamed"
dict set ::pll_all_ip_params gui_active_clk "false"
dict set ::pll_all_ip_params gui_clk_bad "false"
dict set ::pll_all_ip_params gui_switchover_mode "Automatic Switchover"
dict set ::pll_all_ip_params gui_switchover_delay "0"
dict set ::pll_all_ip_params gui_enable_cascade_out "false"
dict set ::pll_all_ip_params gui_cascade_outclk_index "0"
dict set ::pll_all_ip_params gui_enable_cascade_in "false"
dict set ::pll_all_ip_params gui_enable_permit_cal "false"
dict set ::pll_all_ip_params gui_enable_upstream_out_clk "false"
dict set ::pll_all_ip_params gui_pll_cascading_mode "adjpllin"
dict set ::pll_all_ip_params gui_enable_mif_dps "false"
dict set ::pll_all_ip_params gui_dps_cntr "C0"
dict set ::pll_all_ip_params gui_dps_num "1"
dict set ::pll_all_ip_params gui_dps_dir "Positive"
dict set ::pll_all_ip_params gui_extclkout_0_source "C0"
dict set ::pll_all_ip_params gui_extclkout_1_source "C0"
dict set ::pll_all_ip_params gui_clock_name_global "false"
dict set ::pll_all_ip_params gui_clock_name_string0 "outclk0"
dict set ::pll_all_ip_params gui_clock_name_string1 "outclk1"
dict set ::pll_all_ip_params gui_clock_name_string2 "outclk2"
dict set ::pll_all_ip_params gui_clock_name_string3 "outclk3"
dict set ::pll_all_ip_params gui_clock_name_string4 "outclk4"
dict set ::pll_all_ip_params gui_clock_name_string5 "outclk5"
dict set ::pll_all_ip_params gui_clock_name_string6 "outclk6"
dict set ::pll_all_ip_params gui_clock_name_string7 "outclk7"
dict set ::pll_all_ip_params gui_clock_name_string8 "outclk8"
dict set ::pll_all_ip_params gui_clock_name_string9 "outclk9"
dict set ::pll_all_ip_params gui_clock_name_string10 "outclk10"
dict set ::pll_all_ip_params gui_clock_name_string11 "outclk11"
dict set ::pll_all_ip_params gui_clock_name_string12 "outclk12"
dict set ::pll_all_ip_params gui_clock_name_string13 "outclk13"
dict set ::pll_all_ip_params gui_clock_name_string14 "outclk14"
dict set ::pll_all_ip_params gui_clock_name_string15 "outclk15"
dict set ::pll_all_ip_params gui_clock_name_string16 "outclk16"
dict set ::pll_all_ip_params gui_clock_name_string17 "outclk17"
dict set ::pll_all_ip_params gui_divide_factor_c0 "6"
dict set ::pll_all_ip_params gui_divide_factor_c1 "6"
dict set ::pll_all_ip_params gui_divide_factor_c2 "6"
dict set ::pll_all_ip_params gui_divide_factor_c3 "6"
dict set ::pll_all_ip_params gui_divide_factor_c4 "6"
dict set ::pll_all_ip_params gui_divide_factor_c5 "6"
dict set ::pll_all_ip_params gui_divide_factor_c6 "6"
dict set ::pll_all_ip_params gui_divide_factor_c7 "6"
dict set ::pll_all_ip_params gui_divide_factor_c8 "6"
dict set ::pll_all_ip_params gui_divide_factor_c9 "6"
dict set ::pll_all_ip_params gui_divide_factor_c10 "6"
dict set ::pll_all_ip_params gui_divide_factor_c11 "6"
dict set ::pll_all_ip_params gui_divide_factor_c12 "6"
dict set ::pll_all_ip_params gui_divide_factor_c13 "6"
dict set ::pll_all_ip_params gui_divide_factor_c14 "6"
dict set ::pll_all_ip_params gui_divide_factor_c15 "6"
dict set ::pll_all_ip_params gui_divide_factor_c16 "6"
dict set ::pll_all_ip_params gui_divide_factor_c17 "6"
dict set ::pll_all_ip_params gui_cascade_counter0 "false"
dict set ::pll_all_ip_params gui_cascade_counter1 "false"
dict set ::pll_all_ip_params gui_cascade_counter2 "false"
dict set ::pll_all_ip_params gui_cascade_counter3 "false"
dict set ::pll_all_ip_params gui_cascade_counter4 "false"
dict set ::pll_all_ip_params gui_cascade_counter5 "false"
dict set ::pll_all_ip_params gui_cascade_counter6 "false"
dict set ::pll_all_ip_params gui_cascade_counter7 "false"
dict set ::pll_all_ip_params gui_cascade_counter8 "false"
dict set ::pll_all_ip_params gui_cascade_counter9 "false"
dict set ::pll_all_ip_params gui_cascade_counter10 "false"
dict set ::pll_all_ip_params gui_cascade_counter11 "false"
dict set ::pll_all_ip_params gui_cascade_counter12 "false"
dict set ::pll_all_ip_params gui_cascade_counter13 "false"
dict set ::pll_all_ip_params gui_cascade_counter14 "false"
dict set ::pll_all_ip_params gui_cascade_counter15 "false"
dict set ::pll_all_ip_params gui_cascade_counter16 "false"
dict set ::pll_all_ip_params gui_cascade_counter17 "false"
dict set ::pll_all_ip_params gui_output_clock_frequency0 "1250.0"
dict set ::pll_all_ip_params gui_output_clock_frequency1 "125.0"
dict set ::pll_all_ip_params gui_output_clock_frequency2 "1250.0"
dict set ::pll_all_ip_params gui_output_clock_frequency3 "125.0"
dict set ::pll_all_ip_params gui_output_clock_frequency4 "125.0"
dict set ::pll_all_ip_params gui_output_clock_frequency5 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency6 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency7 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency8 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency9 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency10 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency11 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency12 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency13 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency14 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency15 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency16 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency17 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps0 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps1 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps2 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps3 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps4 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps5 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps6 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps7 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps8 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps9 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps10 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps11 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps12 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps13 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps14 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps15 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps16 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps17 "10000.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency0 "1250.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency1 "125.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency2 "1250.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency3 "125.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency4 "125.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency5 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency6 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency7 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency8 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency9 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency10 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency11 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency12 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency13 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency14 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency15 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency16 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency17 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range0 "208.333333 250.0 312.5 416.666667 625.0 1250.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range1 "96.153846 104.166667 113.636364 125.0 138.888889 156.25"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range2 "208.333333 250.0 312.5 416.666667 625.0 1250.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range3 "96.153846 104.166667 113.636364 125.0 138.888889 156.25"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range4 "96.153846 104.166667 113.636364 125.0 138.888889 156.25"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range5 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range6 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range7 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range8 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range9 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range10 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range11 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range12 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range13 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range14 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range15 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range16 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range17 "100.0"
dict set ::pll_all_ip_params gui_ps_units0 "ps"
dict set ::pll_all_ip_params gui_ps_units1 "ps"
dict set ::pll_all_ip_params gui_ps_units2 "ps"
dict set ::pll_all_ip_params gui_ps_units3 "ps"
dict set ::pll_all_ip_params gui_ps_units4 "ps"
dict set ::pll_all_ip_params gui_ps_units5 "ps"
dict set ::pll_all_ip_params gui_ps_units6 "ps"
dict set ::pll_all_ip_params gui_ps_units7 "ps"
dict set ::pll_all_ip_params gui_ps_units8 "ps"
dict set ::pll_all_ip_params gui_ps_units9 "ps"
dict set ::pll_all_ip_params gui_ps_units10 "ps"
dict set ::pll_all_ip_params gui_ps_units11 "ps"
dict set ::pll_all_ip_params gui_ps_units12 "ps"
dict set ::pll_all_ip_params gui_ps_units13 "ps"
dict set ::pll_all_ip_params gui_ps_units14 "ps"
dict set ::pll_all_ip_params gui_ps_units15 "ps"
dict set ::pll_all_ip_params gui_ps_units16 "ps"
dict set ::pll_all_ip_params gui_ps_units17 "ps"
dict set ::pll_all_ip_params gui_phase_shift0 "400.0"
dict set ::pll_all_ip_params gui_phase_shift1 "7200.0"
dict set ::pll_all_ip_params gui_phase_shift2 "400.0"
dict set ::pll_all_ip_params gui_phase_shift3 "7200.0"
dict set ::pll_all_ip_params gui_phase_shift4 "400.0"
dict set ::pll_all_ip_params gui_phase_shift5 "0.0"
dict set ::pll_all_ip_params gui_phase_shift6 "0.0"
dict set ::pll_all_ip_params gui_phase_shift7 "0.0"
dict set ::pll_all_ip_params gui_phase_shift8 "0.0"
dict set ::pll_all_ip_params gui_phase_shift9 "0.0"
dict set ::pll_all_ip_params gui_phase_shift10 "0.0"
dict set ::pll_all_ip_params gui_phase_shift11 "0.0"
dict set ::pll_all_ip_params gui_phase_shift12 "0.0"
dict set ::pll_all_ip_params gui_phase_shift13 "0.0"
dict set ::pll_all_ip_params gui_phase_shift14 "0.0"
dict set ::pll_all_ip_params gui_phase_shift15 "0.0"
dict set ::pll_all_ip_params gui_phase_shift16 "0.0"
dict set ::pll_all_ip_params gui_phase_shift17 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg0 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg1 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg2 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg3 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg4 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg5 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg6 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg7 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg8 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg9 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg10 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg11 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg12 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg13 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg14 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg15 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg16 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift0 "400.0"
dict set ::pll_all_ip_params gui_actual_phase_shift1 "7200.0"
dict set ::pll_all_ip_params gui_actual_phase_shift2 "400.0"
dict set ::pll_all_ip_params gui_actual_phase_shift3 "7200.0"
dict set ::pll_all_ip_params gui_actual_phase_shift4 "400.0"
dict set ::pll_all_ip_params gui_actual_phase_shift5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range0 "100.0 200.0 300.0 400.0 500.0 600.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range1 "6900.0 7000.0 7100.0 7200.0 7300.0 7400.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range2 "100.0 200.0 300.0 400.0 500.0 600.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range3 "6900.0 7000.0 7100.0 7200.0 7300.0 7400.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range4 "100.0 200.0 300.0 400.0 500.0 600.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg0 "180.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg1 "324.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg2 "180.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg3 "324.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg4 "18.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range0 "45.0 90.0 135.0 180.0 225.0 270.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range1 "310.5 315.0 319.5 324.0 328.5 333.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range2 "45.0 90.0 135.0 180.0 225.0 270.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range3 "310.5 315.0 319.5 324.0 328.5 333.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range4 "4.5 9.0 13.5 18.0 22.5 27.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range17 "0.0"
dict set ::pll_all_ip_params gui_duty_cycle0 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle1 "10.0"
dict set ::pll_all_ip_params gui_duty_cycle2 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle3 "10.0"
dict set ::pll_all_ip_params gui_duty_cycle4 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle5 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle6 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle7 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle8 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle9 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle10 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle11 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle12 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle13 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle14 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle15 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle16 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle17 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle0 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle1 "10.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle2 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle3 "10.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle4 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle5 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle6 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle7 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle8 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle9 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle10 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle11 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle12 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle13 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle14 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle15 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle16 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle17 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range0 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range1 "5.0 10.0 15.0 20.0 25.0 30.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range2 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range3 "5.0 10.0 15.0 20.0 25.0 30.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range4 "35.0 40.0 45.0 50.0 55.0 60.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range5 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range6 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range7 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range8 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range9 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range10 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range11 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range12 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range13 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range14 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range15 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range16 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range17 "50.0"
dict set ::pll_all_ip_params gui_simulation_type "false"
dict set ::pll_all_ip_params parameterTable_names "{M-Counter Divide Setting} {N-Counter Divide Setting} {VCO Frequency} {C-Counter-0 Divide Setting} {C-Counter-1 Divide Setting} {C-Counter-2 Divide Setting} {C-Counter-3 Divide Setting} {C-Counter-4 Divide Setting} {C-Counter-5 Divide Setting} {C-Counter-6 Divide Setting} {C-Counter-7 Divide Setting} {C-Counter-8 Divide Setting} {PLL Auto Reset} {M-Counter Hi Divide} {M-Counter Lo Divide} {M-Counter Even Duty Enable} {M-Counter Bypass Enable} {N-Counter Hi Divide} {N-Counter Lo Divide} {N-Counter Even Duty Enable} {N-Counter Bypass Enable} {C-Counter-0 Hi Divide} {C-Counter-1 Hi Divide} {C-Counter-2 Hi Divide} {C-Counter-3 Hi Divide} {C-Counter-4 Hi Divide} {C-Counter-5 Hi Divide} {C-Counter-6 Hi Divide} {C-Counter-7 Hi Divide} {C-Counter-8 Hi Divide} {C-Counter-0 Lo Divide} {C-Counter-1 Lo Divide} {C-Counter-2 Lo Divide} {C-Counter-3 Lo Divide} {C-Counter-4 Lo Divide} {C-Counter-5 Lo Divide} {C-Counter-6 Lo Divide} {C-Counter-7 Lo Divide} {C-Counter-8 Lo Divide} {C-Counter-0 Even Duty Enable} {C-Counter-1 Even Duty Enable} {C-Counter-2 Even Duty Enable} {C-Counter-3 Even Duty Enable} {C-Counter-4 Even Duty Enable} {C-Counter-5 Even Duty Enable} {C-Counter-6 Even Duty Enable} {C-Counter-7 Even Duty Enable} {C-Counter-8 Even Duty Enable} {C-Counter-0 Bypass Enable} {C-Counter-1 Bypass Enable} {C-Counter-2 Bypass Enable} {C-Counter-3 Bypass Enable} {C-Counter-4 Bypass Enable} {C-Counter-5 Bypass Enable} {C-Counter-6 Bypass Enable} {C-Counter-7 Bypass Enable} {C-Counter-8 Bypass Enable} {C-Counter-0 Preset} {C-Counter-1 Preset} {C-Counter-2 Preset} {C-Counter-3 Preset} {C-Counter-4 Preset} {C-Counter-5 Preset} {C-Counter-6 Preset} {C-Counter-7 Preset} {C-Counter-8 Preset} {C-Counter-0 Phase Mux Preset} {C-Counter-1 Phase Mux Preset} {C-Counter-2 Phase Mux Preset} {C-Counter-3 Phase Mux Preset} {C-Counter-4 Phase Mux Preset} {C-Counter-5 Phase Mux Preset} {C-Counter-6 Phase Mux Preset} {C-Counter-7 Phase Mux Preset} {C-Counter-8 Phase Mux Preset} {Charge Pump Current} {Bandwidth Control}"
dict set ::pll_all_ip_params parameterTable_values "10 1 {1250.0 MHz} 1 10 1 10 10 1 1 1 1 false 5 5 false false 256 256 false true 256 1 256 1 5 256 256 256 256 256 9 256 9 5 256 256 256 256 false false false false false false false false false true false true false false true true true true 1 10 1 10 1 1 1 1 1 4 0 4 0 4 0 0 0 0 pll_cp_setting11 pll_bw_res_setting2"
dict set ::pll_all_ip_params mifTable_names "{The MIF file specified does not yet exist}"
dict set ::pll_all_ip_params pll_m_cnt_basic "1"
dict set ::pll_all_ip_params pll_m_cnt "1"
dict set ::pll_all_ip_params prot_mode "BASIC"
dict set ::pll_all_ip_params protocol_mode "PROTOCOL_MODE_BASIC"
dict set ::pll_all_ip_params m_cnt_hi_div "5"
dict set ::pll_all_ip_params eff_m_cnt "1"
dict set ::pll_all_ip_params multiply_factor "10"
dict set ::pll_all_ip_params use_core_refclk "false"
dict set ::pll_all_ip_params m_cnt_lo_div "5"
dict set ::pll_all_ip_params n_cnt_hi_div "256"
dict set ::pll_all_ip_params n_cnt_lo_div "256"
dict set ::pll_all_ip_params m_cnt_bypass_en "false"
dict set ::pll_all_ip_params n_cnt_bypass_en "true"
dict set ::pll_all_ip_params m_cnt_odd_div_duty_en "false"
dict set ::pll_all_ip_params n_cnt_odd_div_duty_en "false"
dict set ::pll_all_ip_params pll_vco_div "1"
dict set ::pll_all_ip_params pll_cp_current "pll_cp_setting11"
dict set ::pll_all_ip_params pll_bwctrl "pll_bw_res_setting2"
dict set ::pll_all_ip_params pll_ripplecap_ctrl "pll_ripplecap_setting1"
dict set ::pll_all_ip_params pll_fractional_division "1"
dict set ::pll_all_ip_params fractional_vco_multiplier "false"
dict set ::pll_all_ip_params reference_clock_frequency "125.0 MHz"
dict set ::pll_all_ip_params pll_fractional_cout "1"
dict set ::pll_all_ip_params pll_dsm_out_sel "1st_order"
dict set ::pll_all_ip_params operation_mode "direct"
dict set ::pll_all_ip_params number_of_clocks "5"
dict set ::pll_all_ip_params number_of_outclks "5"
dict set ::pll_all_ip_params pll_vcoph_div "1"
dict set ::pll_all_ip_params pll_type "TOP_BOTTOM"
dict set ::pll_all_ip_params pll_subtype "General"
dict set ::pll_all_ip_params pll_output_clk_frequency "1250.0 MHz"
dict set ::pll_all_ip_params pll_pfd_frequency "125.0 MHz"
dict set ::pll_all_ip_params mimic_fbclk_type "gclk"
dict set ::pll_all_ip_params pll_bw_sel "hi_bw"
dict set ::pll_all_ip_params pll_slf_rst "false"
dict set ::pll_all_ip_params pll_fbclk_mux_1 "pll_fbclk_mux_1_glb"
dict set ::pll_all_ip_params pll_fbclk_mux_2 "pll_fbclk_mux_2_m_cnt"
dict set ::pll_all_ip_params pll_m_cnt_in_src "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params pll_clkin_0_src "ioclkin_0"
dict set ::pll_all_ip_params refclk1_frequency "100.0 MHz"
dict set ::pll_all_ip_params pll_clk_loss_sw_en "false"
dict set ::pll_all_ip_params pll_manu_clk_sw_en "false"
dict set ::pll_all_ip_params pll_auto_clk_sw_en "false"
dict set ::pll_all_ip_params pll_clkin_1_src "ioclkin_0"
dict set ::pll_all_ip_params pll_clk_sw_dly "0"
dict set ::pll_all_ip_params pll_extclk_0_cnt_src "pll_extclk_cnt_src_vss"
dict set ::pll_all_ip_params pll_extclk_1_cnt_src "pll_extclk_cnt_src_vss"
dict set ::pll_all_ip_params pll_lock_fltr_cfg "100"
dict set ::pll_all_ip_params pll_unlock_fltr_cfg "2"
dict set ::pll_all_ip_params lock_mode "low_lock_time"
dict set ::pll_all_ip_params clock_to_compensate "1"
dict set ::pll_all_ip_params clock_name_global "false"
dict set ::pll_all_ip_params pll_freqcal_en "true"
dict set ::pll_all_ip_params pll_defer_cal_user_mode "true"
dict set ::pll_all_ip_params dprio_interface_sel "3"
dict set ::pll_all_ip_params merging_permitted "false"
dict set ::pll_all_ip_params bandwidth_mode "BANDWIDTH_MODE_AUTO"
dict set ::pll_all_ip_params compensation_clk_source "COMPENSATION_CLK_SOURCE_UNUSED"
dict set ::pll_all_ip_params compensation_mode "COMPENSATION_MODE_DIRECT"
dict set ::pll_all_ip_params cascade_mode "CASCADE_MODE_STANDALONE"
dict set ::pll_all_ip_params base_address "0"
dict set ::pll_all_ip_params fb_clk_delay "0"
dict set ::pll_all_ip_params fb_clk_fractional_div_den "1"
dict set ::pll_all_ip_params fb_clk_fractional_div_num "1"
dict set ::pll_all_ip_params fb_clk_fractional_div_value "1"
dict set ::pll_all_ip_params fb_clk_m_div "0"
dict set ::pll_all_ip_params out_clk_cascading_source "OUT_CLK_CASCADING_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_external_0_source "OUT_CLK_EXTERNAL_0_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_external_1_source "OUT_CLK_EXTERNAL_1_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_periph_0_delay "0"
dict set ::pll_all_ip_params out_clk_periph_0_en "true"
dict set ::pll_all_ip_params out_clk_periph_1_delay "0"
dict set ::pll_all_ip_params out_clk_periph_1_en "true"
dict set ::pll_all_ip_params ref_clk_delay "0"
dict set ::pll_all_ip_params ref_clk_n_div "1"
dict set ::pll_all_ip_params set_dutycycle "SET_DUTYCYCLE_FRACTION"
dict set ::pll_all_ip_params set_fractional "SET_FRACTIONAL_FRACTION"
dict set ::pll_all_ip_params set_freq "SET_FREQ_DIVISION"
dict set ::pll_all_ip_params set_phase "SET_PHASE_NUM_SHIFTS"
dict set ::pll_all_ip_params pfd_clk_freq "100000000"
dict set ::pll_all_ip_params vco_clk_freq "1000000000"
dict set ::pll_all_ip_params c_cnt_hi_div0 "256"
dict set ::pll_all_ip_params c_cnt_hi_div1 "1"
dict set ::pll_all_ip_params c_cnt_hi_div2 "256"
dict set ::pll_all_ip_params c_cnt_hi_div3 "1"
dict set ::pll_all_ip_params c_cnt_hi_div4 "5"
dict set ::pll_all_ip_params c_cnt_hi_div5 "256"
dict set ::pll_all_ip_params c_cnt_hi_div6 "256"
dict set ::pll_all_ip_params c_cnt_hi_div7 "256"
dict set ::pll_all_ip_params c_cnt_hi_div8 "256"
dict set ::pll_all_ip_params c_cnt_hi_div9 "1"
dict set ::pll_all_ip_params c_cnt_hi_div10 "1"
dict set ::pll_all_ip_params c_cnt_hi_div11 "1"
dict set ::pll_all_ip_params c_cnt_hi_div12 "1"
dict set ::pll_all_ip_params c_cnt_hi_div13 "1"
dict set ::pll_all_ip_params c_cnt_hi_div14 "1"
dict set ::pll_all_ip_params c_cnt_hi_div15 "1"
dict set ::pll_all_ip_params c_cnt_hi_div16 "1"
dict set ::pll_all_ip_params c_cnt_hi_div17 "1"
dict set ::pll_all_ip_params c_cnt_lo_div0 "256"
dict set ::pll_all_ip_params c_cnt_lo_div1 "9"
dict set ::pll_all_ip_params c_cnt_lo_div2 "256"
dict set ::pll_all_ip_params c_cnt_lo_div3 "9"
dict set ::pll_all_ip_params c_cnt_lo_div4 "5"
dict set ::pll_all_ip_params c_cnt_lo_div5 "256"
dict set ::pll_all_ip_params c_cnt_lo_div6 "256"
dict set ::pll_all_ip_params c_cnt_lo_div7 "256"
dict set ::pll_all_ip_params c_cnt_lo_div8 "256"
dict set ::pll_all_ip_params c_cnt_lo_div9 "1"
dict set ::pll_all_ip_params c_cnt_lo_div10 "1"
dict set ::pll_all_ip_params c_cnt_lo_div11 "1"
dict set ::pll_all_ip_params c_cnt_lo_div12 "1"
dict set ::pll_all_ip_params c_cnt_lo_div13 "1"
dict set ::pll_all_ip_params c_cnt_lo_div14 "1"
dict set ::pll_all_ip_params c_cnt_lo_div15 "1"
dict set ::pll_all_ip_params c_cnt_lo_div16 "1"
dict set ::pll_all_ip_params c_cnt_lo_div17 "1"
dict set ::pll_all_ip_params c_cnt_prst0 "1"
dict set ::pll_all_ip_params c_cnt_prst1 "10"
dict set ::pll_all_ip_params c_cnt_prst2 "1"
dict set ::pll_all_ip_params c_cnt_prst3 "10"
dict set ::pll_all_ip_params c_cnt_prst4 "1"
dict set ::pll_all_ip_params c_cnt_prst5 "1"
dict set ::pll_all_ip_params c_cnt_prst6 "1"
dict set ::pll_all_ip_params c_cnt_prst7 "1"
dict set ::pll_all_ip_params c_cnt_prst8 "1"
dict set ::pll_all_ip_params c_cnt_prst9 "1"
dict set ::pll_all_ip_params c_cnt_prst10 "1"
dict set ::pll_all_ip_params c_cnt_prst11 "1"
dict set ::pll_all_ip_params c_cnt_prst12 "1"
dict set ::pll_all_ip_params c_cnt_prst13 "1"
dict set ::pll_all_ip_params c_cnt_prst14 "1"
dict set ::pll_all_ip_params c_cnt_prst15 "1"
dict set ::pll_all_ip_params c_cnt_prst16 "1"
dict set ::pll_all_ip_params c_cnt_prst17 "1"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst0 "4"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst1 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst2 "4"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst3 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst4 "4"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst5 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst6 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst7 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst8 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst9 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst10 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst11 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst12 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst13 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst14 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst15 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst16 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst17 "0"
dict set ::pll_all_ip_params c_cnt_in_src0 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src1 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src2 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src3 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src4 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src5 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src6 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src7 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src8 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src9 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src10 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src11 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src12 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src13 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src14 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src15 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src16 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src17 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_bypass_en0 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en1 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en2 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en3 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en4 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en5 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en6 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en7 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en8 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en9 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en10 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en11 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en12 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en13 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en14 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en15 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en16 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en17 "true"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en0 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en1 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en2 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en3 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en4 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en5 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en6 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en7 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en8 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en9 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en10 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en11 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en12 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en13 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en14 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en15 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en16 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en17 "false"
dict set ::pll_all_ip_params output_clock_frequency0 "1250.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency1 "125.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency2 "1250.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency3 "125.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency4 "125.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency5 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency6 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency7 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency8 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency9 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency10 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency11 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency12 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency13 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency14 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency15 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency16 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency17 "0 MHz"
dict set ::pll_all_ip_params phase_shift0 "400 ps"
dict set ::pll_all_ip_params phase_shift1 "7200 ps"
dict set ::pll_all_ip_params phase_shift2 "400 ps"
dict set ::pll_all_ip_params phase_shift3 "7200 ps"
dict set ::pll_all_ip_params phase_shift4 "400 ps"
dict set ::pll_all_ip_params phase_shift5 "0 ps"
dict set ::pll_all_ip_params phase_shift6 "0 ps"
dict set ::pll_all_ip_params phase_shift7 "0 ps"
dict set ::pll_all_ip_params phase_shift8 "0 ps"
dict set ::pll_all_ip_params phase_shift9 "0 ps"
dict set ::pll_all_ip_params phase_shift10 "0 ps"
dict set ::pll_all_ip_params phase_shift11 "0 ps"
dict set ::pll_all_ip_params phase_shift12 "0 ps"
dict set ::pll_all_ip_params phase_shift13 "0 ps"
dict set ::pll_all_ip_params phase_shift14 "0 ps"
dict set ::pll_all_ip_params phase_shift15 "0 ps"
dict set ::pll_all_ip_params phase_shift16 "0 ps"
dict set ::pll_all_ip_params phase_shift17 "0 ps"
dict set ::pll_all_ip_params duty_cycle0 "50"
dict set ::pll_all_ip_params duty_cycle1 "10"
dict set ::pll_all_ip_params duty_cycle2 "50"
dict set ::pll_all_ip_params duty_cycle3 "10"
dict set ::pll_all_ip_params duty_cycle4 "50"
dict set ::pll_all_ip_params duty_cycle5 "50"
dict set ::pll_all_ip_params duty_cycle6 "50"
dict set ::pll_all_ip_params duty_cycle7 "50"
dict set ::pll_all_ip_params duty_cycle8 "50"
dict set ::pll_all_ip_params duty_cycle9 "50"
dict set ::pll_all_ip_params duty_cycle10 "50"
dict set ::pll_all_ip_params duty_cycle11 "50"
dict set ::pll_all_ip_params duty_cycle12 "50"
dict set ::pll_all_ip_params duty_cycle13 "50"
dict set ::pll_all_ip_params duty_cycle14 "50"
dict set ::pll_all_ip_params duty_cycle15 "50"
dict set ::pll_all_ip_params duty_cycle16 "50"
dict set ::pll_all_ip_params duty_cycle17 "50"
dict set ::pll_all_ip_params clock_name_0 "outclk0"
dict set ::pll_all_ip_params clock_name_1 "outclk1"
dict set ::pll_all_ip_params clock_name_2 "outclk2"
dict set ::pll_all_ip_params clock_name_3 "outclk3"
dict set ::pll_all_ip_params clock_name_4 "outclk4"
dict set ::pll_all_ip_params clock_name_global_0 "false"
dict set ::pll_all_ip_params clock_name_global_1 "false"
dict set ::pll_all_ip_params clock_name_global_2 "false"
dict set ::pll_all_ip_params clock_name_global_3 "false"
dict set ::pll_all_ip_params clock_name_global_4 "false"
dict set ::pll_all_ip_params clock_name_global_5 "false"
dict set ::pll_all_ip_params clock_name_global_6 "false"
dict set ::pll_all_ip_params clock_name_global_7 "false"
dict set ::pll_all_ip_params clock_name_global_8 "false"
dict set ::pll_all_ip_params divide_factor0 "1"
dict set ::pll_all_ip_params divide_factor1 "1"
dict set ::pll_all_ip_params divide_factor2 "1"
dict set ::pll_all_ip_params divide_factor3 "1"
dict set ::pll_all_ip_params divide_factor4 "1"
dict set ::pll_all_ip_params divide_factor5 "1"
dict set ::pll_all_ip_params divide_factor6 "1"
dict set ::pll_all_ip_params divide_factor7 "1"
dict set ::pll_all_ip_params divide_factor8 "1"
dict set ::pll_all_ip_params out_clk_0_c_div "1"
dict set ::pll_all_ip_params out_clk_1_c_div "1"
dict set ::pll_all_ip_params out_clk_2_c_div "1"
dict set ::pll_all_ip_params out_clk_3_c_div "1"
dict set ::pll_all_ip_params out_clk_4_c_div "1"
dict set ::pll_all_ip_params out_clk_5_c_div "1"
dict set ::pll_all_ip_params out_clk_6_c_div "1"
dict set ::pll_all_ip_params out_clk_0_core_en "true"
dict set ::pll_all_ip_params out_clk_1_core_en "true"
dict set ::pll_all_ip_params out_clk_2_core_en "true"
dict set ::pll_all_ip_params out_clk_3_core_en "true"
dict set ::pll_all_ip_params out_clk_4_core_en "true"
dict set ::pll_all_ip_params out_clk_5_core_en "true"
dict set ::pll_all_ip_params out_clk_6_core_en "true"
dict set ::pll_all_ip_params out_clk_0_delay "0"
dict set ::pll_all_ip_params out_clk_1_delay "0"
dict set ::pll_all_ip_params out_clk_2_delay "0"
dict set ::pll_all_ip_params out_clk_3_delay "0"
dict set ::pll_all_ip_params out_clk_4_delay "0"
dict set ::pll_all_ip_params out_clk_5_delay "0"
dict set ::pll_all_ip_params out_clk_6_delay "0"
dict set ::pll_all_ip_params out_clk_0_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_1_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_2_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_3_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_4_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_5_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_6_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_0_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_1_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_2_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_3_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_4_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_5_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_6_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_0_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_1_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_2_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_3_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_4_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_5_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_6_phase_shifts "0"
dict set ::pll_all_ip_params ref_clk_0_freq "100000000"
dict set ::pll_all_ip_params ref_clk_1_freq "100000000"
dict set ::pll_all_ip_params out_clk_0_freq "1000000000"
dict set ::pll_all_ip_params out_clk_1_freq "1000000000"
dict set ::pll_all_ip_params out_clk_2_freq "1000000000"
dict set ::pll_all_ip_params out_clk_3_freq "1000000000"
dict set ::pll_all_ip_params out_clk_4_freq "1000000000"
dict set ::pll_all_ip_params out_clk_5_freq "1000000000"
dict set ::pll_all_ip_params out_clk_6_freq "1000000000"
dict set ::pll_all_ip_params out_clk_0_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_1_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_2_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_3_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_4_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_5_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_6_phase_ps "1000000000"
dict set ::pll_all_ip_params pll_tclk_mux_en "false"
dict set ::pll_all_ip_params pll_tclk_sel "pll_tclk_m_src"
dict set ::pll_all_ip_params pll_vco_freq_band_0 "pll_freq_clk0_band18"
dict set ::pll_all_ip_params pll_vco_freq_band_1 "pll_freq_clk1_band18"
dict set ::pll_all_ip_params pll_freqcal_req_flag "true"
dict set ::pll_all_ip_params cal_converge "false"
dict set ::pll_all_ip_params cal_error "cal_clean"
dict set ::pll_all_ip_params pll_cal_done "false"
dict set ::pll_all_ip_params include_iossm "false"
dict set ::pll_all_ip_params cal_code_hex_file "iossm.hex"
dict set ::pll_all_ip_params parameter_table_hex_file "seq_params_sim.hex"
dict set ::pll_all_ip_params iossm_nios_sim_clk_period_ps "1333"
dict set ::pll_all_ip_params hp_number_of_family_allowable_clocks "9"
dict set ::pll_all_ip_params hp_previous_num_clocks "1"
dict set ::pll_all_ip_params hp_actual_vco_frequency_fp "1250.0"
dict set ::pll_all_ip_params hp_qsys_scripting_mode "true"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp0 "1250.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp1 "125.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp2 "1250.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp3 "125.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp4 "125.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp5 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp6 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp7 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp8 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp9 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp10 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp11 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp12 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp13 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp14 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp15 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp16 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp17 "100.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp0 "400.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp1 "7200.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp2 "400.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp3 "7200.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp4 "400.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp5 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp6 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp7 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp8 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp9 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp10 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp11 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp12 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp13 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp14 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp15 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp16 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp17 "0.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp0 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp1 "10.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp2 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp3 "10.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp4 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp5 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp6 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp7 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp8 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp9 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp10 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp11 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp12 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp13 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp14 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp15 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp16 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp17 "50.0"
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 17 altera_iopll_1931 5 synth 50 eth_tse_0_altera_iopll_1931_c6qpzfa_parameters.tcl 12098 # PLL Parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!
#USER To ensure timing constraints and timing reports are correct, when you make 
#USER any changes to the PLL component using the Qsys,
#USER apply those changes to the PLL parameters in this file

set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename eth_tse_0_altera_iopll_1931_c6qpzfa

set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data [dict create]
set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data [dict create]
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk pattern __inst_name__|tennm_pll|refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk node_type pin
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk port_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk port_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk is_fpga_pin false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk is_main_refclk true
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk name "__inst_name___refclk"
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk period 8.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data refclk half_period 4.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock pattern __inst_name__|tennm_pll~ncntr_reg
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock node_type register
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock is_valid false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock name "__inst_name___n_cnt_clk"
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock src refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock multiply_by 1
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock divide_by 1
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock phase 0.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data n_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock pattern __inst_name__|tennm_pll~mcntr_reg
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock node_type register
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock is_valid false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock name "__inst_name___m_cnt_clk"
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock src refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock multiply_by 1
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock divide_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock phase 0.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data m_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph pattern __inst_name__|tennm_pll|vcoph\[0\]
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph node_type pin
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph is_valid false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph name "__inst_name___vcoph"
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph src refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph multiply_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph divide_by 1
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph phase 0
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data vcoph duty_cycle 50
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 pattern __inst_name__|tennm_pll|lvds_clk\[0\]
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 node_type pin
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 is_valid false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 name "__inst_name___fclk0"
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 src refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 multiply_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 divide_by 1
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 phase 180.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 duty_cycle 50
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds0 counter_index 0
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 pattern __inst_name__|tennm_pll|loaden\[0\]
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 node_type pin
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 is_valid false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 name "__inst_name___loaden0"
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 src refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 multiply_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 divide_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 phase 324.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 duty_cycle 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 counter_index 1
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 through_pin __inst_name__|tennm_pll|lock
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds1 max_delay 16.0
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 pattern __inst_name__|tennm_pll|lvds_clk\[1\]
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 node_type pin
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 is_valid false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 name "__inst_name___fclk1"
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 src refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 multiply_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 divide_by 1
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 phase 180.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 duty_cycle 50
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds2 counter_index 2
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 pattern __inst_name__|tennm_pll|loaden\[1\]
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 node_type pin
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 is_valid false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 name "__inst_name___loaden1"
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 src refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 multiply_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 divide_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 phase 324.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 duty_cycle 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 counter_index 3
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 through_pin __inst_name__|tennm_pll|lock
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data lvds3 max_delay 16.0
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 pattern __inst_name__|tennm_pll|outclk\[4\]
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 node_type pin
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 pin_id ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 pin_node_name ""
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 is_valid false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 exists false
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 name __inst_name___outclk4
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 src refclk
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 multiply_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 divide_by 10
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 phase 18.000
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 duty_cycle 50
dict set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data outclk4 counter_index 4
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 17 altera_iopll_1931 5 synth 47 eth_tse_0_altera_iopll_1931_c6qpzfa_pin_map.tcl 37858 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the traversal routines that are used by
# eth_tse_0_altera_iopll_1931_c6qpzfa.sdc scripts. 
#
# These routines are only meant to support the SDC. 
# Trying to using them in a different context can have unexpected 
# results.

set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_debug 0

set script_dir [file dirname [info script]]

source [file join $script_dir eth_tse_0_altera_iopll_1931_c6qpzfa_parameters.tcl]

proc get_warnings_disabled {} {
    set local_disable_warnings true
    set inis [split [get_global_assignment -name INI_VARS] ";"]
    foreach ini $inis {
        set ini_lst [split $ini "="]
        lassign $ini_lst ini_name ini_value
        if {$ini_name == "disable_warnings" && $ini_value == "off"} {
            set local_disable_warnings false
            break
        }
    }
    return $local_disable_warnings 
}
set ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_disable_warnings [get_warnings_disabled]

# ----------------------------------------------------------------
#
proc ai_post_message {msg_type msg {msg_context sta_only}} {
#
# Description: Posts a message to Quartus, depending on 
# msg_context (sta_only, all)
#              
#              
#
# ----------------------------------------------------------------

    if {$msg_type == "debug"} {
        if {$::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_debug} {
            puts $msg
        }
    } else {
        if {$msg_context == "all"} {
            post_message -type $msg_type $msg
        } elseif {$msg_context == "sta_only"} {
            if {$::TimeQuestInfo(nameofexecutable) == "quartus_sta"} {
                post_message -type $msg_type $msg
            }
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_are_entity_names_on { } {
#
# Description: Determines if the entity names option is on
#
# ----------------------------------------------------------------
	return [set_project_mode -is_show_entity]	
}

# ----------------------------------------------------------------
#
proc ai_initialize_pll_db { pll_db_par } {
#
# Description: Gets the instances of this particular PLL IP and creates the pin
#              cache
#
# ----------------------------------------------------------------
	upvar $pll_db_par local_pll_db

	global ::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename

	ai_post_message info "Initializing PLL database for CORE $::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename"
	set instance_list [ai_get_core_instance_list $::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename]

	foreach instname $instance_list {
		ai_post_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename INSTANCE: $instname"

		set clock_data_dicts [ai_get_pll_pins $instname]
		lassign $clock_data_dicts base_clock_data_dict gen_clock_data_dict
        print_clock_data $base_clock_data_dict
        print_clock_data $gen_clock_data_dict 

		set local_pll_db($instname) $clock_data_dicts 
	}
}

# ----------------------------------------------------------------
#
proc ai_get_core_instance_list {corename} {
#
# Description: Converts node names from one style to another style
#
# ----------------------------------------------------------------
	set full_instance_list [ai_get_core_full_instance_list $corename]
	set instance_list [list]

	foreach inst $full_instance_list {
		if {[lsearch $instance_list [escape_brackets $inst]] == -1} {
            ai_post_message debug "Found instance:  $inst"
			lappend instance_list $inst
		}
	}
	return $instance_list
}

# ----------------------------------------------------------------
#
proc ai_get_core_full_instance_list {corename} {
#
# Description: Finds the instances of the particular IP by searching through the cells
#
# ----------------------------------------------------------------

	set instance_list [design::get_instances -entity $corename]
                               
	if {[ llength $instance_list ] == 0} {

        if {!$::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_disable_warnings} {
            ai_post_message warning "The auto-constraining script was not able to detect any instance for core < $corename >" all
            ai_post_message warning "Verify the following:"
            ai_post_message warning " The core < $corename > is instantiated within another component (wrapper)" all
            ai_post_message warning " The core is not the top-level of the project" all
        }
	}

	return $instance_list
}
proc ai_get_registers {pattern} {
    if {$::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_disable_warnings} {
        return [get_registers -nowarn -no_duplicates $pattern]
    } else {
        return [get_registers -no_duplicates $pattern]
    }
}
proc ai_get_pins {pattern} {
    if {$::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_corename_disable_warnings} {
        return [get_pins -nowarn -no_duplicates $pattern]
    } else {
        return [get_pins -no_duplicates $pattern]
    }
}
proc ai_get_pin_node_name {pattern} {
    set pin_collection [ai_get_pins $pattern]
    set num_pins [get_collection_size $pin_collection]
    if {$num_pins == 1} {
        foreach_in_collection id $pin_collection {
            set node_name [get_node_info -name $id]	     
            return $node_name
        }
    } 
    return ""
 
}

# ----------------------------------------------------------------
#
proc ai_get_collection_size_from_pattern {pattern} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    set pin_collection [get_pins -no_duplicates $pattern]
    return [get_collection_size $pin_collection]
}

# ----------------------------------------------------------------
#
proc print_clock_data {d} {
#
# Description: Prints clock data dict
#
# ---------------------------------------------------------------- 
    dict for {clock_key info} $d {
        ai_post_message debug "Clock:  $clock_key"
        dict for {key val} $info {
            ai_post_message debug "   $key: $val"
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_subst_instname {clock_data_dict patt} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            regsub -all "__inst_name__" $name $patt new_name
            regsub -all "__inst_name__" $pattern $patt new_pattern
            
            dict set clock_data_dict $clock_key name $new_name
            dict set clock_data_dict $clock_key pattern $new_pattern
            
            if {[dict exists $clock_data_dict $clock_key "through_pin" ]} {
                regsub -all "__inst_name__" $through_pin $patt new_through_pin
                dict set clock_data_dict $clock_key through_pin $new_through_pin
            }
        }
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_update_genclk_div_mult {clock_data_dict pll_parameters_dict} {
#
# Description: Updates the dict with div/mult values collected from
# the PLL's atom parameters.
#
# ----------------------------------------------------------------
    set compensated_counter_div 0
    set clock_to_compensate [dict get $pll_parameters_dict clock_to_compensate]
    # Loop over dict to find the compensated counter's div value first.
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {[info exists counter_index]} { 
                if {$counter_index == $clock_to_compensate} {
                    set compensated_counter_div [dict get $pll_parameters_dict c${counter_index}_total]
                }
            }
        }
        unset -nocomplain counter_index
    }
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Getting div/mult factors for clock $clock_key" 

            set ccnt -1
            if {[info exists counter_index]} {
                set ccnt [dict get $pll_parameters_dict c${counter_index}_total]
			    set ccnt_dc [dict get $pll_parameters_dict duty_cycle${counter_index}]
            } else {
                set counter_index -1
			    set ccnt_dc 50
            }
            set mult_div [ai_get_mult_div_factors \
                $clock_key \
                $src \
                [dict get $pll_parameters_dict n_total] \
                [dict get $pll_parameters_dict m_total] \
                $ccnt \
                $counter_index \
                $compensated_counter_div \
                [dict get $pll_parameters_dict compensation_mode] \
                [dict get $pll_parameters_dict clock_to_compensate]]

            lassign $mult_div mult div

            ai_post_message debug "Setting mult_div factors for: $clock_key to $mult/$div"

            dict set clock_data_dict $clock_key multiply_by $mult
            dict set clock_data_dict $clock_key divide_by $div
            dict set clock_data_dict $clock_key duty_cycle $ccnt_dc
        }
        unset -nocomplain counter_index
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_set_genclk_pin_info {clock_data_dict} {
#
# Description: Updates the dict with pin info collected from making
# STA API calls.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            if {$node_type == "register"} {
                set pin_collection [ai_get_registers $pattern]
            } elseif {$node_type == "pin"} {
                set pin_collection [ai_get_pins $pattern]
            } else {
                ai_post_message "debug" "Incorrect type of node."
            }
            set num_pins [get_collection_size $pin_collection]
            if {$num_pins == 1} {
                # Always set valid to true if we found the pin node
                ai_post_message debug "Setting clock as valid."
                dict set clock_data_dict $clock_key is_valid true
                
                # This for loop should only loop once.
                foreach_in_collection id $pin_collection {
                    set node_name [get_node_info -name $id]	     
                    dict set clock_data_dict $clock_key pin_id $id
                    dict set clock_data_dict $clock_key pin_node_name $node_name
                }
                # Check if clock_exists, if it does, then
                # set key "exists" on the clock info dict.
                dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

            
            } else {
                dict set clock_data_dict $clock_key is_valid false
            }

        }
    }
    return $clock_data_dict
    
    
} 
# ----------------------------------------------------------------
#
proc ai_set_baseclk_pin_info {clock_data_dict refclk_data_dict pll_name} {
#
    # Description: Updates the dict with pin info collected from refclk data
    # dict, which was obtained by traversing netlist.
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_set_baseclk_pin_info"

    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            
            set node_name ""
            dict for {clock_id info} $refclk_data_dict {
                dict with info {
                    # Figure out which refclk is the baseclk based on input muxes 
                    set pll_atom [ai_get_pll_atom $pll_name]
                    set clkin_enum "ENUM_IOPLL_CLKIN_0_SRC"
                    if {!$is_main_refclk} {
                        set clkin_enum "ENUM_IOPLL_CLKIN_1_SRC"
                    }
                    set refclk_src [get_atom_node_info -key $clkin_enum -node $pll_atom]

                    set refclk_port_name "$pattern"
                    if {[regexp {[0-9]+} $refclk_src refclk_index]} {
                        set refclk_port_name "$pattern\[$refclk_index\]"
                    } 
                    if {[string equal -nocase $refclk_port_name $ref_pin_node_name]} {
                        dict set clock_data_dict $clock_key pin_id $ref_pin_id
                        dict set clock_data_dict $clock_key pin_node_name $ref_pin_node_name
                        dict set clock_data_dict $clock_key port_id $ref_port_id
                        dict set clock_data_dict $clock_key port_node_name $ref_port_node_name
                        dict set clock_data_dict $clock_key is_fpga_pin $ref_is_fpga_pin
                        set node_name $ref_port_node_name
                        break
                    }
                }
            }
            # Check if clock_exists, if it does, then
            # set key "exists" on the clock info dict.
            dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

        }
    }
    return $clock_data_dict
    
}
proc ai_get_n_cnt_clock_node_name {gen_clock_data_dict} {
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Clock:  $clock_key, pin_node_name: $pin_node_name"

            if {$clock_key == "n_cnt_clock"} {
                return $pin_node_name
            }
        }
    }
    return ""
}

# ----------------------------------------------------------------
#
proc ai_update_baseclk_data {base_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the refclk information based on atom settings
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_baseclk_data_dict"

    dict for {base_clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_main_refclk} {
                set ref_period [dict get $pll_parameters_dict refclk_period]
                set ref_period [expr round($ref_period * 1000.0)/1000.0] 
                set ref_period [format %.3f $ref_period]
                dict set base_clock_data_dict $base_clock_key period $ref_period

                set half_period [expr $ref_period /2]
                set half_period [expr round($half_period * 1000.0)/1000.0] 
                set half_period [format %.3f $half_period]
                dict set base_clock_data_dict $base_clock_key half_period $half_period
            }
        }
    }

    return $base_clock_data_dict
}

# ----------------------------------------------------------------
#
proc ai_update_genclk_sources {base_clock_data_dict gen_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the genclk data dict with src nodes from the appropriate
    # refclks
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_genclk_sources"

    # Check if vcoph pin exists, if it does then set the clock source
    # as vcoph otherwise set it to either refclk or n_cnt_clock
    set vcoph_exists false
    if {[dict exists $gen_clock_data_dict vcoph]} {
        set vcoph_pin_name [ai_get_pin_node_name [dict get $gen_clock_data_dict vcoph pattern]]
        if {$vcoph_pin_name != ""} {
            ai_post_message debug "vcoph pin name: $vcoph_pin_name "
            set vcoph_exists true
        }
    }

    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Setting src pin info for clock $clock_key"

            set node_name ""
            set main_refclk_key ""
            dict for {base_clock_key info} $base_clock_data_dict {
                dict with info {
                    if {$is_main_refclk} {
                        set main_refclk_key $base_clock_key
                        if {$is_fpga_pin} {
                            set node_name $port_node_name
                        } else {
                            set node_name $pin_node_name
                        }
                        break
                    }
                }
            }
 
            if {$clock_key != "n_cnt_clock" && ![dict get $pll_parameters_dict n_bypass]} {
                set src "n_cnt_clock"
            }

            if {$src == "refclk" || $src == "cascade_in" || $src == "pll_cascade_in" || $src == "core_refclk"} {
                set src_ $node_name
            } elseif {$src == "n_cnt_clock"} {
                set src_ [ai_get_n_cnt_clock_node_name $gen_clock_data_dict]
            } else {
                set src_ "" 
                ai_post_message "warning" "Undefined clock source: $src"

                dict set gen_clock_data_dict $clock_key is_valid false 
            }

            if {$clock_key != "n_cnt_clock" && $clock_key != "vcoph" && $vcoph_exists} {
                set src_ $vcoph_pin_name
            }

            dict set gen_clock_data_dict $clock_key src $src_
        }
    }
    return $gen_clock_data_dict 
    
}
proc ai_invalidate_clocks {clock_data_dict} {
    # Set the is_valid flag on each clock to false
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            dict set clock_data_dict $clock_key is_valid false
        }
    }
    return $clock_data_dict
}
proc ai_get_first_outclk_node {clock_data_dict} {
    set outclk_pin_id "None"
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {$node_type == "pin" && $is_valid} {
                set outclk_pin_id $pin_id
                break
            }
        }
    }
    if {$outclk_pin_id == "None"} {
        ai_post_message "warning" "Could not find any valid outclks"
    }
    return $outclk_pin_id 
}
# ----------------------------------------------------------------
#
proc ai_get_pll_pins { instname } {
#
# Description: Stores the pins of interest for the instance of the IP
#
# ----------------------------------------------------------------

    set base_clock_data_dict $::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_base_clock_data
    set gen_clock_data_dict $::GLOBAL_top_eth_tse_0_altera_iopll_1931_c6qpzfa_gen_clock_data
    # First regsub the instance name for the pin names and patterns.
    set base_clock_data_dict [ai_subst_instname $base_clock_data_dict $instname]
    set gen_clock_data_dict [ai_subst_instname $gen_clock_data_dict $instname]


    set pll_parameters_dict [ai_get_pll_atom_parameters $instname] 
    set gen_clock_data_dict [ai_set_genclk_pin_info $gen_clock_data_dict]

    ai_post_message debug "gen_clock_data_dict initial: "
    print_clock_data $gen_clock_data_dict 
    
    # Traverse the first generated clock back to find FPGA pins for refclks.
    set outclk_node_id [ai_get_first_outclk_node $gen_clock_data_dict]
    if {$outclk_node_id != "None"} {
        set refclk_data_dict [ai_get_input_clk_info $outclk_node_id]
        ai_post_message debug "refclk_data_dict: "
        print_clock_data $refclk_data_dict

        set base_clock_data_dict [ai_set_baseclk_pin_info $base_clock_data_dict $refclk_data_dict $instname]
        set gen_clock_data_dict [ai_update_genclk_sources $base_clock_data_dict $gen_clock_data_dict $pll_parameters_dict]
        set gen_clock_data_dict [ai_update_genclk_div_mult $gen_clock_data_dict $pll_parameters_dict] 
        set base_clock_data_dict [ai_update_baseclk_data $base_clock_data_dict $pll_parameters_dict] 
        ai_post_message debug "base_clock_data_dict: "
        print_clock_data $base_clock_data_dict 
        ai_post_message debug "gen_clock_data_dict final: "
        print_clock_data $gen_clock_data_dict
    } else {
        # Make sure that we don't create any clock constraints
        # if no output clock was found
        set gen_clock_data_dict [ai_invalidate_clocks $gen_clock_data_dict]
    }
    
    return [list $base_clock_data_dict $gen_clock_data_dict]
    
}

# ----------------------------------------------------------------
#
proc ai_get_input_clk_info { outclk_pin_id } {
#
# Description: Searches back from the output of the PLL to find the reference clock pin.
#              If the reference clock is fed by an input buffer, it finds that pin, otherwise
#              in cascading modes it will return the immediate reference clock input of the PLL.
#
# ----------------------------------------------------------------
	if {[ai_is_node_type_pll_clk $outclk_pin_id]} {
        #stores the refclk pin ids that were found by tracing the 
        #output clocks back up
		array set refclk_array [list]
		ai_traverse_fanin_up_to_depth $outclk_pin_id ai_is_node_type_pll_inclk clock refclk_array 20
        array set refclk_info_array [list]
        foreach {net_id id} [array get refclk_array] {
            set net_name [get_node_info -name $net_id]
            set refclk_info_array($net_id) $net_name

        }
        # Dict to hold the refclk info found by traversing the netlist back.
        # refclk_data = {
        #   clock_id = {
        #       ref_pin_id: str,
        #       ref_pin_node_name: str,
        #       ref_port_id: str,
        #       ref_port_node_name: str,
        #       ref_is_fpga_pin: true/false,
        #   }
        # }
        set refclk_data [dict create]
        
        set clock_id 0

        #only works if there is either 1 or 2 refclks
		if {[array size refclk_array] == 1 || [array size refclk_array] == 2} {
            #iterate over each refclk pin and trace back to find its input port
            foreach refclk_pin_id [array names refclk_info_array] {
                array set user_refclk_array [list]
                array unset refclk_array
                array unset user_refclk_array [list]
					 
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_user_clock clock user_refclk_array 5
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_pin clock refclk_array 5
					 
                # If fed by any user specified clock (which could be specified at the pin level or at the
                # buffer level), then use that pin as the source.
                # Otherwise, trace back to the dedicated input pin (depth 5 so that we don't include global clocks)
                if {[array size user_refclk_array] == 1 || [array size refclk_array] < 1} {
                    # Fed by a user specified clock, a global clock etc. 
                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id ""
                    dict set refclk_data $clock_id ref_port_node_name ""
                    dict set refclk_data $clock_id ref_is_fpga_pin false
                } else {
                    # Fed by a dedicated input pin
                    set port_id_ [lindex [array names refclk_array] 0]

                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id $port_id_
                    dict set refclk_data $clock_id ref_port_node_name [get_node_info -name $port_id_]
                    dict set refclk_data $clock_id ref_is_fpga_pin true
                }

                incr clock_id
            }
        } else {
			ai_post_message critical_warning "Could not find PLL ref clock that feeds [get_node_info -name $outclk_pin_id]" all
		}
	} else {
		ai_post_message error "Internal error: ai_get_input_clk_info only works for PLL output clocks" all
	}
	return $refclk_data
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pin { node_id } {
#
# Description: Determines if a node is a top-level port of the FPGA
#
# ----------------------------------------------------------------

	set node_type [get_node_info -type $node_id]
	if {$node_type == "port"} {
		set result 1
	} else {
		set result 0
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_user_clock { node_id } {
#
# Description: Determines if a node is a user-defined clock
#
# ----------------------------------------------------------------
    set node_name [get_node_info -name $node_id]	 
   
    if {[ai_clock_exists $node_name]} {
        return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_clk { node_id } {
#
# Description: Determines if a node is an output of a PLL
#
# ----------------------------------------------------------------

	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
            ai_post_message debug "Node_name: $node_name"
			if {[string match "*fourteennm_pll\|outclk\\\[*\\\]" $node_name]||[string match "*tennm_pll\|outclk\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll~ncntr_reg" $node_name]||[string match "*tennm_pll~ncntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~c*cntr_reg" $node_name]||[string match "*tennm_pll~c*cntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~mcntr_reg" $node_name]||[string match "*tennm_pll~mcntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|lvds_clk\\\[*\\\]" $node_name]||[string match "*tennm_pll\|lvds_clk\\\[*\\\]" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|loaden\\\[*\\\]" $node_name]||[string match "*tennm_pll\|loaden\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|vcoph\\\[*\\\]" $node_name]||[string match "*tennm_pll\|vcoph\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|pll_cascade_out" $node_name]||[string match "*tennm_pll\|pll_cascade_out" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|extclk_output\\\[*\\\]" $node_name]||[string match "*tennm_pll\|extclk_output\\\[*\\\]" $node_name]} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_inclk { node_id } {
#
# Description: Determines if a node is an input of a PLL
#
# ----------------------------------------------------------------


	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
			set fanin_edges [get_node_info -clock_edges $node_id]
			if {([string match "*|refclk\\\[*\\\]" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|pll_cascade_in" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|cascade_in" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|core_refclk" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
#
# Description: General traversal function up until a depth.  Use a function pointer to decide
#              ending conditions.
#
# ----------------------------------------------------------------

	upvar 1 $results_array_name results
	
	if {$depth < 0} {
		error "Internal error: Bad timing netlist search depth"
	}
	set fanin_edges [get_node_info -${edge_type}_edges $node_id]
	set number_of_fanin_edges [llength $fanin_edges]
	for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
		set fanin_edge [lindex $fanin_edges $i]
		set fanin_id [get_edge_info -src $fanin_edge]
		if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
			set results($fanin_id) 1
		} elseif {$depth == 0} {
		} else {
			ai_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
		}
	}
}

# ----------------------------------------------------------------
#
proc ai_index_in_collection { col j } {
#
# Description: Returns a particular index in a collection.
#              Analagous to lindex for lists.
#
# ----------------------------------------------------------------

	set i 0
	foreach_in_collection path $col {
		if {$i == $j} {
			return $path
		}
		set i [expr $i + 1]
	}
	return ""
}

#
# Description: Rounds a given floating point number
#              to 3 decimal places
#
# ----------------------------------------------------------------
proc ai_round_3dp { x } {
    return [expr { round($x * 1000) / 1000.0  } ]
}

# ----------------------------------------------------------------
# Description: Checks whether a given clock already exists 
# ----------------------------------------------------------------
proc ai_clock_exists { clock_name } {
    set clock_found false
    set input_clocks_col [get_clocks -nowarn]
    set num_input_clocks [get_collection_size $input_clocks_col]
    
    if {$num_input_clocks > 0} {
        foreach_in_collection iclk $input_clocks_col {
            if {![is_clock_defined $iclk]} {
                continue
            }

            set clk_targets_col [get_clock_info -target $iclk]
            set num_clk_targets [get_collection_size $clk_targets_col]
            if {$num_clk_targets > 0} {
                foreach_in_collection itgt $clk_targets_col {
                    set node_name [get_node_info -name $itgt]
                    if {[string compare $node_name $clock_name] == 0} {
                        set clock_found true
                        break
                    }
                }
            }
            if {$clock_found == true} {
                break;
            }
        }
    }

   return $clock_found 
}

proc ai_get_pll_atom {instname} {
    foreach_in_collection node [get_atom_nodes -type IOPLL] {
        set name [get_atom_node_info -key NAME -node $node]
        set node_list($name) $node

        if {[string first $instname $name] > -1} {
            return $node
        }
    }
    set sdc_file_name [info script]
    ai_post_message warning "Could not find IOPLL atom with the name <$instname> while processing <$sdc_file_name>. Please check the synthesis report to ensure that the IOPLL was not synthesized away." all
}
proc ai_get_mult_div_factors {clock_key src ncnt mcnt ccnt counter_index \
                              compensated_counter_div compensation_mode \
                              clock_to_compensate} {
    if {$clock_key == "vcoph"} {
        set clock_mult $mcnt
        set clock_div 1
    } elseif {$clock_key == "n_cnt_clock"} {
        set clock_mult 1
        set clock_div $ncnt
    } elseif {$clock_key == "m_cnt_clock"} {
        set clock_mult 1
        set clock_div [expr {$mcnt * $ncnt}]
    } else {

        if {[string first "vcoph" $src] > -1} {
            set clock_mult 1
            set clock_div $ccnt
        } else {
            # Handle NDFB mode. 
            # The equation for counter which is to be compensated: C_k = M / N
            # The equation for all other counters:                 C_!k = (M * C_k) / (N * C_!k)
            if {$compensation_mode == "NON_DEDICATED_SOURCE_SYNC" || $compensation_mode == "NON_DEDICATED_NORMAL"} {
                if {$counter_index == $clock_to_compensate} {
                    set clock_mult $mcnt
                    # Instead of dividing by N, we just divide by 1
                    # since a clock based on the N counter would be created
                    # if N > 1 and this clock would be derived based on that,
                    # so we already have a division happening.
                    set clock_div 1
                } else {
                    set clock_mult [expr $mcnt * $compensated_counter_div]
                    set clock_div $ccnt
                }
            } else {
                ai_post_message debug "Normal C counter"
                set clock_mult $mcnt
                set clock_div $ccnt
            }
        }
    }
    return [list $clock_mult $clock_div]

}
# ----------------------------------------------------------------
#
proc ai_get_pll_atom_parameters {instname} {
#
# Description: Gets the PLL paramaters from the Quartus atom and not 
#              from the IP generated parameters.
#
# ----------------------------------------------------------------

    set pll_atom [ai_get_pll_atom $instname]
																			 
	dict set pll_params compensation_mode [get_atom_node_info -key ENUM_IOPLL_FEEDBACK -node $pll_atom]
	dict set pll_params clock_to_compensate [get_atom_node_info -key INT_IOPLL_CLOCK_TO_COMPENSATE -node $pll_atom]

    # Get refclk frequency (might have changed since IP generation)
    set refclk_freq [get_atom_node_info -key TIME_IOPLL_REFCLK_TIME -node $pll_atom]
    set refclk_int [string trim $refclk_freq "*MHZmhz"]
    set refclk_period [expr 1000.0 / $refclk_int]
    dict set pll_params refclk_period $refclk_period

	dict set pll_params m_hi_div [get_atom_node_info -key INT_IOPLL_M_COUNTER_HIGH -node $pll_atom]
	dict set pll_params m_lo_div [get_atom_node_info -key INT_IOPLL_M_COUNTER_LOW -node $pll_atom]
	dict set pll_params m_bypass [get_atom_node_info -key BOOL_IOPLL_M_COUNTER_BYPASS_EN -node $pll_atom]
    if {[dict get $pll_params m_bypass]} {
        set total 1
    } else {
        set total  [expr [dict get $pll_params m_hi_div] + [dict get $pll_params m_lo_div]]
    }
	dict set pll_params m_total $total

	dict set pll_params n_hi_div [get_atom_node_info -key INT_IOPLL_N_COUNTER_HIGH -node $pll_atom]
	dict set pll_params n_lo_div [get_atom_node_info -key INT_IOPLL_N_COUNTER_LOW -node $pll_atom]
	dict set pll_params n_bypass [get_atom_node_info -key BOOL_IOPLL_N_COUNTER_BYPASS_EN -node $pll_atom]
    if {[dict get $pll_params n_bypass]} {
        set total 1
    } else {
        set total  [expr [dict get $pll_params n_hi_div] + [dict get $pll_params n_lo_div]]
    }
	dict set pll_params n_total $total

	for { set i 0 } { $i < 9} { incr i } {
        # Get the C counter parameter settings from the atom netlist
        dict set pll_params c${i}_hi_div [get_atom_node_info -key INT_IOPLL_C${i}_HIGH -node $pll_atom]
        dict set pll_params c${i}_lo_div [get_atom_node_info -key INT_IOPLL_C${i}_LOW -node $pll_atom]
        dict set pll_params c${i}_bypass [get_atom_node_info -key BOOL_IOPLL_C${i}_BYPASS_EN -node $pll_atom]
        dict set pll_params c${i}_odd_div_duty_en [get_atom_node_info -key BOOL_IOPLL_C${i}_EVEN_DUTY_EN -node $pll_atom]

        # Calculate the total counter value
        if {[dict get $pll_params c${i}_bypass]} {
            set total 1
        } else {
            set total [expr [dict get $pll_params c${i}_hi_div] + [dict get $pll_params c${i}_lo_div]]
        }
        dict set pll_params c${i}_total $total

        # Calculate the duty cycle
        if {[dict get $pll_params c${i}_bypass]} {
            set total_duty 50
        } else {
            if {[dict get $pll_params c${i}_odd_div_duty_en]} {
                set duty_tweak 1
            } else {
                set duty_tweak 0
            }
            set total_duty [expr (([dict get $pll_params c${i}_hi_div] - (0.5*$duty_tweak))*100)/$total]
		    set total_duty [format %.3f $total_duty]
        }
        dict set pll_params duty_cycle${i} $total_duty
    }

    return $pll_params
}

#__ACDS_USER_COMMENT__Set max delay if in fit flow, otherwise set false path through "through_pin"
# originally in the LVDS SDC. This is called if we are exporting loaden to LVDS
proc set_max_delay_in_fit_or_false_path_in_sta_through_no_warn {through_pin delay} {

    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }
    
    # if fit_flow == 1
    if {$::TimeQuestInfo(nameofexecutable) == "quartus_fit" } { 
        set_max_delay -through $through_pin_collection $delay
    } else { 
        set_false_path -through $through_pin_collection
    } 
} 

 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 21 intel_lvds_core10_191 5 synth 43 eth_tse_0_intel_lvds_core10_191_4tqn4ji.sdc 17903 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.




#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing constraints for the Altera LVDS interface


# Source helper script
set script_dir [file dirname [info script]]
source "$script_dir/eth_tse_0_intel_lvds_core10_191_4tqn4ji_ip_parameters.tcl"
source "$script_dir/sdc_util.tcl"

set syn_flow 0
set sta_flow 0
set fit_flow 0
if { $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
    set syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
    set sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
    set fit_flow 1
}



##########################################################################################
# Modifiable user variables
# Change these values to match your design.
##########################################################################################

set ::RCCS 0.0

##########################################################################################
# The following functions are to find out all the instances and the corresponding PLL
# refclk.  If you see an critical warning, modify to match your design.
##########################################################################################


set catch_exception [catch {
    set lvds_instance_name_list [altera_iosubsystem_get_ip_instance_names $ip_params(libname) $ip_params(corename)]
} ]

if {$catch_exception != 0} {
    post_message -type critical_warning "Errors encountered when searching for LVDS instance name and ref clock pin names.  Please override variables lvds_instance_name_list and rerun read_sdc"
    return
}

##########################################################################################
# Derived user variables
##########################################################################################

set half_RCCS [expr $::RCCS / 2]

###########################################################
# IP parameters
###########################################################


# Throw error only at TimeQuest but critical warning in Fitter\n"
if {$fit_flow} {
    set msg_error_type "critical_warning"
} else {
    set msg_error_type "error"
}

# Iterate through all instances of this IP
foreach lvds_instance_name $lvds_instance_name_list {


    set core_clocks [list]
    set periphery_clocks [list]

    set lvds_core_instance_name "${lvds_instance_name}|arch_inst"
    regexp {([0-9_A-Za-z]+)|} $lvds_instance_name -> lvds_top_level_name

    set my_iopll_clks ""
    set lvds_search_mode 2
    set iopll_atom [altera_iosubsystem_get_iopll_atom $lvds_core_instance_name $lvds_search_mode ]
    set refclk_period_ns $ip_params(ref_clock_period_ns)
    set loaden_period_ns $ip_params(slow_clock_period_ns)
    set loaden_phase $ip_params(loaden_phase)
    if {$iopll_atom == ""} {
        if {$sta_flow} {
            post_message -type $msg_error_type "LVDS SDC cannot find IOPLL. Ensure that IOPLL SDC is listed before LVDS SDC in the QSF and that LVDS IP data input/output ports are connected."
        }
    } else {
        set my_iopll_clks [get_iopll_clocks $iopll_atom]
        if { ([get_collection_size $my_iopll_clks] == 0) } {
            if {$sta_flow} {
                post_message -type $msg_error_type "Please ensure the IOPLL IP is before the LVDS IP in the QSF so that clocks are created properly."
            }
        } else {
            set refclk_period_ns [altera_iosubsystem_round_3dp [convert_bigtime_period_ns [get_atom_node_info -key TIME_IOPLL_REFCLK_TIME -node $iopll_atom]]]
            set loaden_period_ns [altera_iosubsystem_round_3dp [convert_bigtime_period_ns [get_atom_node_info -key TIME_IOPLL_OUTCLK1 -node $iopll_atom]]]
            set loaden_phase [altera_iosubsystem_round_3dp [expr [convert_ps_to_degrees [get_atom_node_info -key TIME_IOPLL_PHASE_SHIFT_1 -node $iopll_atom] $loaden_period_ns] / 1000.0]]
        }
    }

    ###########################################################################################
    # Create Common Clocks, Periods, and Delays
    ###########################################################################################

    set pll_fclk_name "${lvds_instance_name}|fclk"
    set pll_lden_name "${lvds_instance_name}|sclk"
    set pll_tx_outclock_fclk_name "${lvds_instance_name}|tx_out_fclk"
    set pll_tx_outclock_lden_name "${lvds_instance_name}|tx_out_sclk"
    set pll_out_name "${lvds_instance_name}|core_clk"
    set core_divider_name "${lvds_instance_name}|core_clk"
    set cpa_core_clk_out_name "${lvds_instance_name}|cpa_clk"

    # Construct port names
    set lvds_clock_tree_inst_name "${lvds_core_instance_name}|rx_channels[*].soft_cdr.lvds_clock_tree_inst"
    set pll_fclk0_tree_name "${lvds_clock_tree_inst_name}|lvds_clk_0"
    set pll_fclk1_tree_name "${lvds_clock_tree_inst_name}|lvds_clk_1"

    # Query clocktree fanin names
    if {[get_collection_size [get_pins -nowarn ${lvds_clock_tree_inst_name}|*]] > 0} {
        if {[catch {
                set pll_fclk0_pin [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $pll_fclk0_tree_name]]]
                set pll_instance_name [get_cell_info -name [get_node_info -cell $pll_fclk0_pin]]
                set pll_ref_ck_pin "${pll_instance_name}|refclk*"
                set ref_ck_port_id [altera_iosubsystem_get_input_clk_id [get_nodes $pll_ref_ck_pin]]
                set ref_ck_pin [get_port_info -name $ref_ck_port_id]
        }]} {
            set pll_fclk0_pin ""
            set pll_ref_ck_pin ""
            set ref_ck_pin ""
            set pll_instance_name ""
        }
        if {[catch {set pll_fclk1_pin [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $pll_fclk1_tree_name]]]}]} {
            set pll_fclk1_pin ""
        }
    } else {
        set pll_fclk0_pin ""
        set pll_fclk1_pin ""
        set pll_ref_ck_pin ""
        set ref_ck_pin ""
        set pll_instance_name ""
    }

    if {$ref_ck_pin != "" && !$ip_params(use_external_pll)} {
        # Create a clock at the reference clock pin, 
        # if one does not already exist.
        if {$ref_ck_pin != ""} {
            if {[altera_iosubsystem_get_clock_name_from_target $ref_ck_pin] == ""} {
                create_clock -name $ref_ck_pin -period $ip_params(ref_clock_period_ns) $ref_ck_pin
            }
        }
    }

    if {$pll_fclk0_pin != ""} {
        lappend periphery_clocks "${pll_fclk_name}\[0\]"
    }

    if {$pll_fclk1_pin != ""} {
        lappend periphery_clocks "${pll_fclk_name}\[1\]"
    }

    # Create the core clock, which clocks the core register.
    #cpa core clk
    set cpa_instance_name "${lvds_core_instance_name}|u_lvds_cpa" 
    set cpa_core_clk_out_pin "${cpa_instance_name}|core_clk_out[0]"

    if {[get_collection_size [get_nodes -nowarn $cpa_core_clk_out_pin]] != 0} {
        altera_iosubsystem_create_generated_clock \
                -source [altera_iosubsystem_get_clock_source "$cpa_core_clk_out_pin"] \
                -divide_by  $ip_params(cdr_core_divide_by) \
                -duty_cycle 50 -phase $ip_params(loaden_phase) \
                -name "${cpa_core_clk_out_name}" -target "${cpa_core_clk_out_pin}" 
        lappend core_clocks  "${cpa_core_clk_out_name}"

        set_false_path -through $cpa_core_clk_out_pin
    }

    lappend core_clocks ${pll_out_name}
    lappend periphery_clocks $pll_fclk_name

    # generate clocks at LVDS data output to capture the proper periphery to core transfer
    for {set ichan 0} {$ichan < $ip_params(num_chan)} {incr ichan} {
        # query for pll pin
        if {[catch {get_node_info -name [altera_iosubsystem_get_src_pll_in_pin ${lvds_core_instance_name}|rx_channels[$ichan].soft_cdr.serdes_dpa_inst~dpa_reg]} pll_in_pin]} {
            if {$ip_params(use_external_pll)} {
                post_message -type $msg_error_type "SDC cannot find the PLL that drives DPA.  Clock settings of channel $ichan are not created.  Please check your external PLL connectivity is in accordance with the Altera LVDS user guide."
            } else {
                post_message -type $msg_error_type "SDC cannot find the PLL that drives DPA.  Clock settings of channel $ichan are not created.  Please check the PLL to LVDS IP connectivity."
            }
            continue;
        }

        # Construct dpa clock and register names.
        set dpa_reg "${lvds_core_instance_name}|rx_channels[$ichan].soft_cdr.serdes_dpa_inst~dpa_reg"
        set dpa_clk "${lvds_instance_name}_dpa_ck_name_$ichan"
        set dpa_reg_neg "${lvds_core_instance_name}|rx_channels[$ichan].soft_cdr.serdes_dpa_inst~dpa_reg__nff"
        set dpa_clk_neg "${lvds_instance_name}_dpa_ck_neg_name_$ichan"

        # Create dpa clock(s)
        # If odd j factor, there is the additional __nff keeper node.
        altera_iosubsystem_create_generated_clock \
                -source [altera_iosubsystem_get_clock_source $dpa_reg] \
                -name $dpa_clk -target $dpa_reg
        lappend periphery_clocks $dpa_clk

        if {$ip_params(odd_jfactor)} {
            altera_iosubsystem_create_generated_clock \
                    -source [altera_iosubsystem_get_clock_source $dpa_reg_neg] \
                    -name $dpa_clk_neg -target $dpa_reg_neg
            lappend periphery_clocks $dpa_clk_neg
        }

        # create core clock
        set core_clk_source [expr $ip_params(odd_jfactor) ? "{$dpa_reg_neg}" : "{$dpa_reg}"]
        set core_clk_name "${lvds_instance_name}_core_ck_name_$ichan"
        set core_clk_pin "${lvds_core_instance_name}|rx_channels[$ichan].soft_cdr.serdes_dpa_inst~O_PCLK"

        altera_iosubsystem_create_generated_clock -invert 1 -source $core_clk_source -name $core_clk_name -divide_by $ip_params(cdr_core_divide_by) -target $core_clk_pin

        lappend core_clocks $core_clk_name

        # create data clocks
        for {set index 0} {$index < $ip_params(j_factor)} {incr index} {
            set clk_name     "${lvds_instance_name}_dpa_data_out_${ichan}_$index"
            set clk_name_neg "${lvds_instance_name}_dpa_data_out_${ichan}_${index}_neg"
            set clk_pin      "${lvds_core_instance_name}|rx_channels[$ichan].soft_cdr.serdes_dpa_inst|par_out[$index]"

            altera_iosubsystem_create_generated_clock \
                    -source $dpa_reg -name $clk_name \
                    -divide_by $ip_params(cdr_core_divide_by) \
                    -target $clk_pin
            altera_iosubsystem_create_generated_clock \
                    -source $dpa_reg -name $clk_name_neg \
                    -divide_by $ip_params(cdr_core_divide_by) \
                    -remove_clock 0 -add 1 -invert 1 \
                    -target $clk_pin

            lappend periphery_clocks $clk_name
            lappend periphery_clocks $clk_name_neg

            set_false_path -fall_from $clk_name
            set_false_path -rise_from $clk_name_neg
        }
    
        set dpa_inst_name ${lvds_core_instance_name}|rx_channels[*].soft_cdr.serdes_dpa_inst
        set dpa_inst_name_short ${lvds_core_instance_name}|rx_channels[${ichan}].soft_cdr
        if {$ip_params(use_bslip)} {
            set_false_path -from ${dpa_inst_name}~dpa_reg -to ${dpa_inst_name_short}.rx_bitslip_max_sync_inst|sync_inst|din_s1 
        }
        if {$ip_params(use_dpa_locked)} {
            set_false_path -from ${dpa_inst_name}~dpa_reg -to ${dpa_inst_name_short}.rx_dpa_locked_sync_inst|sync_inst|din_s1  
        }

    }

    if {$ref_ck_pin != ""} {
        lappend periphery_clocks  "$ref_ck_pin"
    }

    # Set max delay constraints in FIT to avoid ridiculously long path but cut
    # the timing path in STA since we have synchronizers
    set dpa_inst_name ${lvds_core_instance_name}|rx_channels[*].soft_cdr.serdes_dpa_inst
    set max_delay [expr 2*$ip_params(slow_clock_period_ns)]
    set min_delay [expr 0 - $ip_params(slow_clock_period_ns)]
    if {$ip_params(use_bslip)} {
        set_max_delay_in_fit_or_false_path_in_sta_to_fanout_no_warn ${dpa_inst_name}~dpa_reg ${dpa_inst_name}|bslipmax $max_delay
    } 
    if {$ip_params(use_dpa_locked)} {
        set_max_delay_in_fit_or_false_path_in_sta_to_fanout ${dpa_inst_name}~dpa_reg ${dpa_inst_name}|dpalock $max_delay
    } 
    if {$ip_params(device_rev) eq "A"} {
        disable_min_pulse_width ${dpa_inst_name}~dpa_reg
    }

    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn ${dpa_inst_name}|bslipcntl $max_delay
    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn ${dpa_inst_name}|fiforst $max_delay
    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn ${dpa_inst_name}|dparst $max_delay
    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn ${dpa_inst_name}|bsliprst $max_delay

    # ------------------------- #
    # -                       - #
    # --- CLOCK UNCERTAINTY --- #
    # -                       - #
    # ------------------------- #


    if {($fit_flow == 1 || $sta_flow == 1)} {

        # Build target to clock names cache
        #Needed for external PLL mode because the clock name is not the same as the pin name
        ##Ensure that the pll SDC is sourced first.  
        if {$ip_params(use_external_pll)} {
            if { ([get_collection_size [get_clocks -nowarn]] == 0) } {
                post_message -type critical_warning "Please ensure the pll IP is before the lvds IP in the QSF so that clocks are created properly."
            }
        }
       
        array unset target_to_clock_name_map *
        foreach_in_collection iclk_name [get_clocks] {
            if { ![is_clock_defined $iclk_name] } {
               continue
            }
            if { [catch { [get_node_info -name [get_clock_info -target $iclk_name]] } itarget ] } {
                continue
            }
            lappend target_to_clock_name_map($itarget) [get_clock_info -name $iclk_name]
        }

        # Get extra periphery clock uncertainty
        set periphery_clock_uncertainty [list]
        altera_iosubsystem_get_periphery_clock_uncertainty periphery_clock_uncertainty

        if {$fit_flow == 1} {
            set overconstraints [list $ip_params(OC_C2P_SU) $ip_params(OC_C2P_H) $ip_params(OC_P2C_SU) $ip_params(OC_P2C_H)]
        } else {
            set overconstraints [list 0.0 0.0 0.0 0.0]
        }

        # Now loop over core/periphery clocks and set clock uncertainty
        set i_core_clock 0
        foreach core_clock $core_clocks {
            if {$core_clock != ""} {

                if {[info exists target_to_clock_name_map($core_clock)]} {
                    set core_clock_target $target_to_clock_name_map($core_clock)
                } else {
                    set core_clock_target $core_clock
                }
                if {[get_collection_size [get_clocks -nowarn $core_clock_target]]==0} {
                    continue
                }
                set i_periphery_clock 0
                foreach { periphery_clock } $periphery_clocks {

                    if {[info exists target_to_clock_name_map($periphery_clock)]} {
                        set periphery_clock_target $target_to_clock_name_map($periphery_clock)
                    } else {
                        set periphery_clock_target $periphery_clock
                    }
                    if {[get_collection_size [get_clocks -nowarn $periphery_clock_target]]==0} {
                        continue
                    }
                    # For these transfers it is safe to use the -add option since we rely on
                    # derive_clock_uncertainty for the base value.
                    set add_to_derived "-add"
                    set c2p_su         [expr [lindex $overconstraints 0] + [lindex $periphery_clock_uncertainty 0]]
                    set c2p_h          [expr [lindex $overconstraints 1] + [lindex $periphery_clock_uncertainty 1]]
                    set p2c_su         [expr [lindex $overconstraints 2] + [lindex $periphery_clock_uncertainty 2]]
                    set p2c_h          [expr [lindex $overconstraints 3] + [lindex $periphery_clock_uncertainty 3]]

                    set_clock_uncertainty -from [get_clocks $core_clock_target] -to   [get_clocks $periphery_clock_target] -setup $add_to_derived $c2p_su
                    set_clock_uncertainty -from [get_clocks $core_clock_target] -to   [get_clocks $periphery_clock_target] -hold  $add_to_derived $c2p_h
                    set_clock_uncertainty -to   [get_clocks $core_clock_target] -from [get_clocks $periphery_clock_target] -setup $add_to_derived $p2c_su
                    set_clock_uncertainty -to   [get_clocks $core_clock_target] -from [get_clocks $periphery_clock_target] -hold  $add_to_derived $p2c_h

                    incr i_periphery_clock
                }
            }
            incr i_core_clock
        }
    }


}

add_rskm_report_command altera_iosubsystem_report_rskm
add_tccs_report_command altera_iosubsystem_report_tccs
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 21 intel_lvds_core10_191 5 synth 57 eth_tse_0_intel_lvds_core10_191_4tqn4ji_ip_parameters.tcl 2075 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the interface


set ip_params(corename) intel_lvds_core10_eth_tse_0_intel_lvds_core10_191_4tqn4ji
set ip_params(libname) eth_tse_0_intel_lvds_core10_191_4tqn4ji
set ip_params(device_rev) B
set ip_params(j_factor) 10
set ip_params(odd_jfactor) 0
set ip_params(OC_C2P_SU) 0.0
set ip_params(OC_C2P_H) 0.0
set ip_params(OC_P2C_SU) 0.0
set ip_params(OC_P2C_H) 0.0
set ip_params(cpa_enabled) true
set ip_params(cdr_core_divide_by) 10
set ip_params(use_external_pll) 1
set ip_params(ref_clock_period_ns) 8.0
set ip_params(use_tx_outclock) 0
set ip_params(use_tx_coreclock) 1
set ip_params(use_bslip) 0
set ip_params(use_dpa_locked) 1
set ip_params(num_chan) 1
set ip_params(slow_clock_period_ns) 8.0
set ip_params(fast_clock_period_ns) 0.8
set ip_params(sclk_phase) 18.0
set ip_params(fclk_phase) 180
set ip_params(loaden_phase) 324.0
set ip_params(loaden_duty) 10.0
set ip_params(tx_outclock_fclk_phase) 0
set ip_params(tx_outclock_loaden_phase) 0.0
set ip_params(tx_outclock_loaden_duty) 10.0
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 21 intel_lvds_core10_191 5 synth 43 eth_tse_0_intel_lvds_core10_191_vvutosq.sdc 18040 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.




#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing constraints for the Altera LVDS interface


# Source helper script
set script_dir [file dirname [info script]]
source "$script_dir/eth_tse_0_intel_lvds_core10_191_vvutosq_ip_parameters.tcl"
source "$script_dir/sdc_util.tcl"

set syn_flow 0
set sta_flow 0
set fit_flow 0
if { $::TimeQuestInfo(nameofexecutable) == "quartus_syn" } {
    set syn_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_sta" } {
    set sta_flow 1
} elseif { $::TimeQuestInfo(nameofexecutable) == "quartus_fit" } {
    set fit_flow 1
}



##########################################################################################
# Modifiable user variables
# Change these values to match your design.
##########################################################################################

set ::RCCS 0.0

##########################################################################################
# The following functions are to find out all the instances and the corresponding PLL
# refclk.  If you see an critical warning, modify to match your design.
##########################################################################################

set catch_exception [catch {
    set lvds_instance_name_list [altera_iosubsystem_get_ip_instance_names $ip_params(libname) $ip_params(corename)]
} ]

if {$catch_exception != 0} {
    post_message -type critical_warning "Errors encountered when searching for LVDS instance name and ref clock pin names.  Please override variables lvds_instance_name_list and rerun read_sdc"
    return
}

##########################################################################################
# Derived user variables
##########################################################################################

set half_RCCS [expr $::RCCS / 2]

###########################################################
# IP parameters
###########################################################


# Throw error only at TimeQuest but critical warning in Fitter\n"
if {$fit_flow} {
    set msg_error_type "critical_warning"
} else {
    set msg_error_type "error"
}

# Iterate through all instances of this IP
foreach lvds_instance_name $lvds_instance_name_list {


    set core_clocks [list]
    set periphery_clocks [list]

    set lvds_core_instance_name "${lvds_instance_name}|arch_inst"
    regexp {([0-9_A-Za-z]+)|} $lvds_instance_name -> lvds_top_level_name
    
    set my_iopll_clks ""
    if {$ip_params(use_tx_outclock)} {
        set lvds_search_mode 1
    } else {
        set lvds_search_mode 0
    }
    set iopll_atom [altera_iosubsystem_get_iopll_atom $lvds_core_instance_name $lvds_search_mode ]
    set refclk_period_ns $ip_params(ref_clock_period_ns)
    set loaden_period_ns $ip_params(slow_clock_period_ns)
    set loaden_phase $ip_params(loaden_phase)
    if {$iopll_atom == ""} {
        if {$sta_flow} {
            post_message -type $msg_error_type "LVDS SDC cannot find IOPLL. Ensure that IOPLL SDC is listed before LVDS SDC in the QSF and that LVDS IP data input/output ports are connected."
        }
    } else {
        set my_iopll_clks [get_iopll_clocks $iopll_atom]
        if { ([get_collection_size $my_iopll_clks] == 0) } {
            if {$sta_flow} {
                post_message -type $msg_error_type "Please ensure the IOPLL IP is before the LVDS IP in the QSF so that clocks are created properly."
            }
        } else {
            set refclk_period_ns [altera_iosubsystem_round_3dp [convert_bigtime_period_ns [get_atom_node_info -key TIME_IOPLL_REFCLK_TIME -node $iopll_atom]]]
            set loaden_period_ns [altera_iosubsystem_round_3dp [convert_bigtime_period_ns [get_atom_node_info -key TIME_IOPLL_OUTCLK1 -node $iopll_atom]]]
            set loaden_phase [altera_iosubsystem_round_3dp [expr [convert_ps_to_degrees [get_atom_node_info -key TIME_IOPLL_PHASE_SHIFT_1 -node $iopll_atom] $loaden_period_ns] / 1000.0]]
        }
    }

    ###########################################################################################
    # Create Common Clocks, Periods, and Delays
    ###########################################################################################

    # Construct clock names
    set pll_fclk_name "${lvds_instance_name}|fclk"
    set pll_lden_name "${lvds_instance_name}|sclk"
    set pll_tx_outclock_fclk_name "${lvds_instance_name}|tx_out_fclk"
    set pll_tx_outclock_lden_name "${lvds_instance_name}|tx_out_sclk"
    set pll_out_name "${lvds_instance_name}|core_clk"
    set cpa_core_clk_out_name "${lvds_instance_name}|cpa_clk"

    # Construct port names
    set lvds_clock_tree_inst_name "${lvds_core_instance_name}|tx_channels[*].tx.lvds_clock_tree_inst"
    set pll_fclk0_tree_name "${lvds_clock_tree_inst_name}|lvds_clk_0"
    set pll_lden0_tree_name "${lvds_clock_tree_inst_name}|loaden_0"
    set pll_fclk1_tree_name "${lvds_clock_tree_inst_name}|lvds_clk_1"
    set pll_lden1_tree_name "${lvds_clock_tree_inst_name}|loaden_1"

    # Query clocktree fanin names
    if {[get_collection_size [get_pins -nowarn ${lvds_clock_tree_inst_name}|*]] > 0} {
        if {[catch {
                set pll_fclk0_pin [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $pll_fclk0_tree_name]]]
                set pll_instance_name [get_cell_info -name [get_node_info -cell $pll_fclk0_pin]]
                set pll_ref_ck_pin "${pll_instance_name}|refclk*"
                set ref_ck_port_id [altera_iosubsystem_get_input_clk_id [get_nodes $pll_ref_ck_pin]]
                set ref_ck_pin [get_port_info -name $ref_ck_port_id]
        }]} {
            set pll_fclk0_pin ""
            set pll_ref_ck_pin ""
            set ref_ck_pin ""
            set pll_instance_name ""
        }
        if {[catch {set pll_lden0_pin [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $pll_lden0_tree_name]]]}]} {
            set pll_lden0_pin ""
        }
        if {[catch {set pll_fclk1_pin [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $pll_fclk1_tree_name]]]}]} {
            set pll_fclk1_pin ""
        }
        if {[catch {set pll_lden1_pin [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $pll_lden1_tree_name]]]}]} {
            set pll_lden1_pin ""
        }
    } else {
        set pll_fclk0_pin ""
        set pll_lden0_pin ""
        set pll_fclk1_pin ""
        set pll_lden1_pin ""
        set pll_ref_ck_pin ""
        set ref_ck_pin ""
        set pll_instance_name ""
    }

    if {$ref_ck_pin != "" && !$ip_params(use_external_pll)} {
        # Create a clock at the reference clock pin, 
        # if one does not already exist.
        if {[altera_iosubsystem_get_clock_name_from_target $ref_ck_pin] == ""} {
            create_clock -name $ref_ck_pin -period $ip_params(ref_clock_period_ns) $ref_ck_pin
        }
    }

    if {$pll_fclk0_pin != ""} {
        lappend periphery_clocks "${pll_fclk_name}\[0\]"
    }

    if {$pll_fclk1_pin != ""} {
        lappend periphery_clocks "${pll_fclk_name}\[1\]"
    }

    if {$pll_lden0_pin != "" } {
        lappend periphery_clocks "${pll_lden_name}\[0\]"
        if {$sta_flow} {
            set_false_path -from $pll_lden0_pin
        }
    }
    
    if {$pll_lden1_pin != "" } {
        lappend periphery_clocks "${pll_lden_name}\[1\]"
        if {$sta_flow} {
            set_false_path -from $pll_lden1_pin
        }
    }

    # TX exported clock.  This clock runs off its own clock tree, and has its own fclk and loaden.
    if {$ip_params(use_tx_outclock)} {
        set tx_outclock_lvds_clock_tree_inst_name "${lvds_core_instance_name}|phase_shifted_tx_outclock_serdes.lvds_clock_tree_clk_inst"

        set pll_tx_outclock_fclk_tree_name "${lvds_clock_tree_inst_name}|lvds_clk_1"
        set pll_tx_outclock_lden_tree_name "${lvds_clock_tree_inst_name}|loaden_1"

        if {[catch {
            set pll_tx_outclock_fclk_pin [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $pll_tx_outclock_fclk_tree_name]]]
            set pll_tx_outclock_lden_pin [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $pll_tx_outclock_lden_tree_name]]]
        }]} {
            set pll_tx_outclock_fclk_pin ""
            set pll_tx_outclock_lden_pin ""
        }

        if {$pll_tx_outclock_fclk_pin != ""} {
            lappend periphery_clocks $pll_tx_outclock_fclk_name
        }

        if {$pll_tx_outclock_lden_pin != ""} {
            lappend periphery_clocks $pll_tx_outclock_lden_name

            if {$sta_flow} {
                set_false_path -from $pll_tx_outclock_lden_pin
            }
        }
    }

    if {[get_collection_size [get_keepers -nowarn ${lvds_core_instance_name}|*tx_outclock_serdes.serdes_dpa_tx_outclock~tx_internal_reg]] > 0 } {
        set_false_path -from ${lvds_core_instance_name}|*tx_outclock_serdes.ser[*].txin_ufi~ufi_read_reg -to ${lvds_core_instance_name}|*tx_outclock_serdes.serdes_dpa_tx_outclock~tx_internal_reg
    }

    # Create the tx core clock, if using it to clock the core register.  Otherwise, the input clock is forwarded to the core.
    if {$ip_params(use_tx_coreclock)} {
        set cpa_instance_name "${lvds_core_instance_name}|u_lvds_cpa" 
        set cpa_core_clk_out_pin "${cpa_instance_name}|core_clk_out[0]"

        altera_iosubsystem_create_generated_clock \
                -source [altera_iosubsystem_get_clock_source "$cpa_core_clk_out_pin"] \
                -divide_by  $ip_params(cdr_core_divide_by) \
                -duty_cycle 50 -phase $ip_params(loaden_phase) \
                -name "${cpa_core_clk_out_name}" -target "${cpa_core_clk_out_pin}" 
        lappend core_clocks  "${cpa_core_clk_out_name}"

        disable_min_pulse_width "$cpa_instance_name~pa_feedback_div_core0_reg"
        lappend periphery_clocks  "$ref_ck_pin"
    } else {
        lappend core_clocks  "$ref_ck_pin"
    }

    set internal_reg "${lvds_core_instance_name}|tx_channels[*].tx.serdes_dpa_inst~tx_internal_reg"

    # Set multicycle to model actual transfer frequency
    #Set multicycle. The actual multitcycle doesn't matter, except that all bits transfer in the same multicycle.
    set setup_multicyle [expr int($ip_params(j_factor)/2)]
    set_multicycle_path -end -from ${lvds_core_instance_name}|tx_channels[*].tx.ser[*].txin_ufi~ufi_read_reg -to $internal_reg -setup $setup_multicyle
    set_multicycle_path -end -from ${lvds_core_instance_name}|tx_channels[*].tx.ser[*].txin_ufi~ufi_read_reg -to $internal_reg -hold [expr $ip_params(j_factor) -1]
    set_multicycle_path -from ${lvds_core_instance_name}*ufi_write_reg -to ${lvds_core_instance_name}*ufi_read_reg -hold 1
    
    if {$ip_params(j_factor) != 10} {
        set_false_path -from ${lvds_core_instance_name}|tx_channels[*].tx.ser_padding[*].txpadding_ufi~ufi_read_reg -to $internal_reg
    }

    disable_min_pulse_width_no_warn "${lvds_core_instance_name}|phase_shifted_tx_outclock_serdes.serdes_dpa_tx_outclock~tx_internal_reg"
    disable_min_pulse_width_no_warn "${lvds_core_instance_name}|phase_shifted_tx_outclock_serdes.serdes_dpa_tx_outclock|fclk_in[1]"
    disable_min_pulse_width_no_warn "${lvds_core_instance_name}|phase_shifted_tx_outclock_serdes.lvds_clock_tree_inst|phy_clk_out_0[*]"
    disable_min_pulse_width_no_warn "${lvds_core_instance_name}|std_tx_outclock_serdes.serdes_dpa_tx_outclock~tx_internal_reg"
    disable_min_pulse_width_no_warn "${lvds_core_instance_name}|std_tx_outclock_serdes.serdes_dpa_tx_outclock~tx_internal_reg__nff"
    disable_min_pulse_width_no_warn "${lvds_core_instance_name}|std_tx_outclock_serdes.serdes_dpa_tx_outclock|fclk_in[1]"
    disable_min_pulse_width_no_warn "${lvds_core_instance_name}|std_tx_outclock_serdes.lvds_clock_tree_inst|phy_clk_out_0[*]"
    disable_min_pulse_width $internal_reg
    disable_min_pulse_width "${lvds_core_instance_name}|tx_channels[*].tx.serdes_dpa_inst|fclk_in[1]"
    disable_min_pulse_width "${lvds_core_instance_name}|tx_channels[*].tx.lvds_clock_tree_inst|phy_clk_out_0[*]"

    if {$::TCCS_USE_MICRO == 0 && $sta_flow} {
        set_false_path -from ${lvds_core_instance_name}|tx_channels[*].tx.serdes_dpa_inst~tx_internal_reg
    }


    # Set max delay constraints in FIT to avoid ridiculously long path but cut
    # the timing path in STA since we have synchronizers
    set dpa_inst_name ${lvds_core_instance_name}|tx_channels[*].tx.serdes_dpa_inst
    set max_delay [expr 2*$ip_params(slow_clock_period_ns)]
    set min_delay [expr 0 - $ip_params(slow_clock_period_ns)]

    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn ${dpa_inst_name}|fiforst $max_delay
    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn ${dpa_inst_name}|dparst $max_delay
    set_max_delay_in_fit_or_false_path_in_sta_through_no_warn ${dpa_inst_name}|bsliprst $max_delay

    # ------------------------- #
    # -                       - #
    # --- CLOCK UNCERTAINTY --- #
    # -                       - #
    # ------------------------- #


    if {($fit_flow == 1 || $sta_flow == 1)} {

        # Build target to clock names cache
        #Needed for external PLL mode because the clock name is not the same as the pin name
        ##Ensure that the pll SDC is sourced first.  
        if {$ip_params(use_external_pll)} { 
            if { ([get_collection_size [get_clocks -nowarn]] == 0) } {
                post_message -type critical_warning "Please ensure the pll IP is before the lvds IP in the QSF so that clocks are created properly."
            }
        }
        
        array unset target_to_clock_name_map *
        foreach_in_collection iclk_name [get_clocks] {
            if { ![is_clock_defined $iclk_name] } {
               continue
            }
            if { [catch { [get_node_info -name [get_clock_info -target $iclk_name]] } itarget ] } {
                continue
            }
            lappend target_to_clock_name_map($itarget) [get_clock_info -name $iclk_name]
        }

        # Get extra periphery clock uncertainty
        set periphery_clock_uncertainty [list]
        altera_iosubsystem_get_periphery_clock_uncertainty periphery_clock_uncertainty

        if {$fit_flow == 1} {
            set overconstraints [list $ip_params(OC_C2P_SU) $ip_params(OC_C2P_H) $ip_params(OC_P2C_SU) $ip_params(OC_P2C_H)]
        } else {
            set overconstraints [list 0.0 0.0 0.0 0.0]
        }

        # Now loop over core/periphery clocks and set clock uncertainty
        set i_core_clock 0
        foreach core_clock $core_clocks {
            if {$core_clock != ""} {

                if {[info exists target_to_clock_name_map($core_clock)]} {
                    set core_clock_target $target_to_clock_name_map($core_clock)
                } else {
                    set core_clock_target $core_clock
                }
                if {[get_collection_size [get_clocks -nowarn $core_clock_target]]==0} {
                    continue
                }
                set i_periphery_clock 0
                foreach { periphery_clock } $periphery_clocks {

                    if {[info exists target_to_clock_name_map($periphery_clock)]} {
                        set periphery_clock_target $target_to_clock_name_map($periphery_clock)
                    } else {
                        set periphery_clock_target $periphery_clock
                    }
                    if {[get_collection_size [get_clocks -nowarn $periphery_clock_target]]==0} {
                        continue
                    }
                    # For these transfers it is safe to use the -add option since we rely on
                    # derive_clock_uncertainty for the base value.
                    set add_to_derived "-add"
                    set c2p_su         [expr [lindex $overconstraints 0] + [lindex $periphery_clock_uncertainty 0]]
                    set c2p_h          [expr [lindex $overconstraints 1] + [lindex $periphery_clock_uncertainty 1]]
                    set p2c_su         [expr [lindex $overconstraints 2] + [lindex $periphery_clock_uncertainty 2]]
                    set p2c_h          [expr [lindex $overconstraints 3] + [lindex $periphery_clock_uncertainty 3]]


                    set_clock_uncertainty -from [get_clocks $core_clock_target] -to   [get_clocks $periphery_clock_target] -setup $add_to_derived $c2p_su
                    set_clock_uncertainty -from [get_clocks $core_clock_target] -to   [get_clocks $periphery_clock_target] -hold  $add_to_derived $c2p_h
                    set_clock_uncertainty -to   [get_clocks $core_clock_target] -from [get_clocks $periphery_clock_target] -setup $add_to_derived $p2c_su
                    set_clock_uncertainty -to   [get_clocks $core_clock_target] -from [get_clocks $periphery_clock_target] -hold  $add_to_derived $p2c_h

                    incr i_periphery_clock
                }
            }
            incr i_core_clock
        }
    }


}

add_rskm_report_command altera_iosubsystem_report_rskm
add_tccs_report_command altera_iosubsystem_report_tccs
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 21 intel_lvds_core10_191 5 synth 57 eth_tse_0_intel_lvds_core10_191_vvutosq_ip_parameters.tcl 1947 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file specifies the timing properties of the interface


set ip_params(corename) intel_lvds_core10_eth_tse_0_intel_lvds_core10_191_vvutosq
set ip_params(libname) eth_tse_0_intel_lvds_core10_191_vvutosq
set ip_params(device_rev) B
set ip_params(j_factor) 10
set ip_params(odd_jfactor) 0
set ip_params(OC_C2P_SU) 0.1
set ip_params(OC_C2P_H) 0.1
set ip_params(OC_P2C_SU) 0.0
set ip_params(OC_P2C_H) 0.0
set ip_params(cpa_enabled) true
set ip_params(cdr_core_divide_by) 10
set ip_params(use_external_pll) 1
set ip_params(ref_clock_period_ns) 8.0
set ip_params(use_tx_outclock) 0
set ip_params(use_tx_coreclock) 1
set ip_params(use_bslip) 0
set ip_params(use_dpa_locked) 0
set ip_params(num_chan) 1
set ip_params(slow_clock_period_ns) 8.0
set ip_params(fast_clock_period_ns) 0.8
set ip_params(sclk_phase) 18.0
set ip_params(fclk_phase) 180
set ip_params(loaden_phase) 324.0
set ip_params(loaden_duty) 10.0
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 9 eth_tse_0 21 intel_lvds_core10_191 5 synth 12 sdc_util.tcl 30632 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# Check whether a project has already been opened
if {[catch {get_current_project}]} {
	post_message -type error "Please open a project first"
	return
}

proc altera_iosubsystem_create_generated_clock {args} {
   array set opts {  -invert 0 \
      -add 0 \
      -remove_clock 1 \
      -name "" \
      -target "" \
      -source "" \
      -multiply_by 1 \
      -divide_by 1 \
      -phase 0 \
		-duty_cycle 50.00  }

   array set opts $args

   set multiply_by [expr int($opts(-multiply_by))]
   if {[expr $multiply_by - $opts(-multiply_by)] != 0.0} {
      post_message -type error "Specify an integer ranging from 0 to 99999999 for the option -multiply_by"
      return ""
   }
	
   if {$opts(-remove_clock)==1} {
      set clock_name_to_remove [altera_iosubsystem_get_clock_name_from_target $opts(-target)]
      if {$clock_name_to_remove != ""} {
         foreach i $clock_name_to_remove {
            remove_clock  [get_clock_info -name $i]
         }
      }
   }
	
   set extra_params [list]
   if {$opts(-invert)==1} {
      lappend extra_params "-invert"
   }
   if {$opts(-add)==1} {
      lappend extra_params "-add"
   }
   
   if {$extra_params == ""} {
      eval {create_generated_clock -name $opts(-name) -source $opts(-source) -multiply_by $multiply_by -divide_by $opts(-divide_by) -phase $opts(-phase) -duty_cycle $opts(-duty_cycle) $opts(-target)}
   } else {
      eval {create_generated_clock {*}$extra_params -name $opts(-name) -source $opts(-source) -multiply_by $multiply_by -divide_by $opts(-divide_by) -phase $opts(-phase) -duty_cycle $opts(-duty_cycle) $opts(-target)}
   }
   
}

proc altera_iosubsystem_get_clock_name_from_target { target } {
   set clock_name [list]
   foreach_in_collection i [get_clocks -nowarn] {
      if {![is_clock_defined $i]} {
         continue
      }
      if { [catch { get_node_info -name  [get_clock_info -targets $i] } i_target ] } {
         continue
      }
      if {[string equal $target $i_target]} {
         lappend clock_name [get_clock_info -name $i]
      }
   }
   return $clock_name
}

proc altera_iosubsystem_get_ip_instance_names { libname corename } {
   set inst_keepers [get_keepers "*$libname*|$corename:arch_inst*" ]
   set channel_keepers [get_keepers "*channels*0*" ]

   set_project_mode -always_show_entity_name on

   set inst_regexp {(^.*\m}
   append inst_regexp "$libname"
   append inst_regexp {\M.*)\|}
   append inst_regexp "$corename"
   append inst_regexp {:arch_inst|channels[0]}

   foreach_in_collection keeper $inst_keepers {
      if {[regexp -- $inst_regexp [ get_node_info -name $keeper ] -> hier_name] == 1} {
         set instance_array([altera_iosubsystem_get_timequest_name $hier_name]) 1
      }
   }
   foreach_in_collection keeper $channel_keepers {
      if {[regexp -- $inst_regexp [ get_node_info -name $keeper ] -> hier_name] == 1} {
         set instance_array([altera_iosubsystem_get_timequest_name $hier_name]) 1
      }
   }

   set instance_list [array names instance_array]

   set_project_mode -always_show_entity_name qsf

   if {[ llength $instance_list ] == 0} {
      post_message -type critical_warning "The auto-constraining script was not able to detect any instance for lib < $libname > core < $corename >"
      post_message -type critical_warning "Make sure the core < $corename > is instantiated within another component (wrapper)"
      post_message -type critical_warning "and it's not the top-level for your project"
   }

   return $instance_list
}

#----------------------------------------------------------------
#
proc altera_iosubsystem_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
#
#Description: Calls the recurse procedure to find nodes, scaling
#             depth if necessary to account for extended netlist
#             (which includes REs) for the hyper-retimer
#
#----------------------------------------------------------------
   upvar 1 $results_array_name results

   set depth [expr {$depth * 10}]
   altera_iosubsystem_traverse_fanin_up_to_depth_recurse $node_id $match_command $edge_type results $depth
}

#----------------------------------------------------------------
#
proc altera_iosubsystem_traverse_fanin_up_to_depth_recurse { node_id match_command edge_type results_array_name depth} {
#
#Description: Recurses through the timing netlist starting from the given
#             node_id through edges of type edge_type to find nodes
#             satisfying match_command.
#             Recursion depth is bound to the specified depth.
#             Adds the resulting TDB node ids to the results_array.
#
#----------------------------------------------------------------
   upvar 1 $results_array_name results

   if {$depth < 0} {
      error "Internal error: Bad timing netlist search depth"
   }
   set fanin_edges [get_node_info -${edge_type}_edges $node_id]
   set number_of_fanin_edges [llength $fanin_edges]
   for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
      set fanin_edge [lindex $fanin_edges $i]
      set fanin_id [get_edge_info -src $fanin_edge]
      if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
         set results($fanin_id) 1
      } elseif {$depth == 0} {
      } else {
         altera_iosubsystem_traverse_fanin_up_to_depth_recurse $fanin_id $match_command $edge_type results [expr {$depth - 1}]
      }
   }
}

proc altera_iosubsystem_get_timequest_name { full_hier_name } {
   set tq_name ""
   set tq_name_list {}
   set lib_inst_pair_list [split $full_hier_name "|"]
   foreach i_lib_inst_pair_str $lib_inst_pair_list {
      set i_lib_inst_pair [split $i_lib_inst_pair_str ":"]
      if {[llength $i_lib_inst_pair] > 1} {
         lappend tq_name_list [join [lrange $i_lib_inst_pair 1 end] :]
      } else {
         lappend tq_name_list [lindex $i_lib_inst_pair end]
      }
   }
   set tq_name [join $tq_name_list "|"]
   return $tq_name
}

proc altera_iosubsystem_get_input_clk_id { pll_inclk_id } {

   array set results_array [list]

   altera_iosubsystem_traverse_fanin_up_to_depth $pll_inclk_id altera_iosubsystem_is_node_type_pin clock results_array 20
   if {[array size results_array] == 1} {
      set pin_id [lindex [array names results_array] 0]
      set result $pin_id
   } else {
      set result -1
   }

   return $result
}

proc altera_iosubsystem_get_src_pin_name { target_node_name {max_depth 5} } {
   if {[expr [get_global_assignment -name "HYPER_RETIMER"] == "ON"]} {
	   set max_depth [expr {$max_depth * 10}]
   }

   altera_iosubsystem_get_src_pin_name_recurse $target_node_name $max_depth
}

proc altera_iosubsystem_get_src_pin_name_recurse { target_node_name {max_depth 5} } {
   set prefix [join [lrepeat [expr 5-$max_depth+1] "\t"] ""]

   if {$max_depth == 0} {
      return $target_node_name
   }

   set catch_get_src [catch {get_node_info -name [get_edge_info -src [get_node_info -clock_edges $target_node_name]]} src_node_name] 
   
   if {$catch_get_src == 0} {
      if {[altera_iosubsystem_is_node_type_pin $src_node_name]} {
         return $src_node_name 
      } else {
         set recur_src_node_name [altera_iosubsystem_get_src_pin_name_recurse $src_node_name [expr $max_depth-1]]
         if {$recur_src_node_name == $src_node_name} {
            return $target_node_name
         } else {
            return $recur_src_node_name
         }
      }
   } else {
      return $target_node_name
   }
}

#----------------------------------------------------------------
#
proc altera_iosubsystem_is_node_type_pin { node_id } {
#
#Description: Given a node, tells whether or not it is a reg
#
#----------------------------------------------------------------
   set node_type [get_node_info -type $node_id]
   if {$node_type == "port"} {
      set result 1
   } else {
      set result 0
   }
   return $result
}


#----------------------------------------------------------------
#
proc altera_iosubsystem_is_node_pll_in_pin {node_id} {
#
#Description: Given a node, tells whether or not it is a PLL input pin
#
#----------------------------------------------------------------
	set node_type [get_node_info -type $node_id]
	set cell_wysiwyg_type [get_cell_info -wysiwyg_type [get_node_info -cell $node_id]]
	if {$node_type == "pin" && $cell_wysiwyg_type == "tennm_iopll" && [get_pin_info -is_in_pin $node_id] == 1} {
		set result 1
	} else {
		set result 0
	}
	return $result
}

#----------------------------------------------------------------
#
proc altera_iosubsystem_is_node_pll_out_pin {node_id} {
#
#Description: Given a node, tells whether or not it is a PLL output pin
#
#----------------------------------------------------------------
	set node_type [get_node_info -type $node_id]
	set cell_wysiwyg_type [get_cell_info -wysiwyg_type [get_node_info -cell $node_id]]
	if {$node_type == "pin" && $cell_wysiwyg_type == "tennm_iopll" && [get_pin_info -is_out_pin $node_id] == 1} {
		set result 1
	} else {
		set result 0
	}
	return $result
}

#----------------------------------------------------------------
#
proc altera_iosubsystem_get_src_pll_in_pin {node_id} { 
#
#Description: Given a node, find all fanins which are PLL input pins
#
#----------------------------------------------------------------
	array set result_array [list]
	
	altera_iosubsystem_traverse_fanin_up_to_depth $node_id altera_iosubsystem_is_node_pll_in_pin clock result_array 10
	return [array names result_array]

}

#----------------------------------------------------------------
#
proc altera_iosubsystem_get_src_pll_out_pin {node_id} { 
#
#Description: Given a node, find all fanins which are PLL output pins
#
#----------------------------------------------------------------
	array set result_array [list]
	
	altera_iosubsystem_traverse_fanin_up_to_depth $node_id altera_iosubsystem_is_node_pll_out_pin clock result_array 10
	return [array names result_array]

}


proc altera_iosubsystem_get_pll_inclock_name_list { lvds_inst_name_list } {

	set pll_inclock_name_list {}
	
	foreach i_lvds_inst_name $lvds_inst_name_list {
		set i_pll_inclk_name [altera_iosubsystem_get_pll_inclock_name $i_lvds_inst_name]
		lappend pll_inclock_name_list $i_pll_inclk_name
	}
	
	return $pll_inclock_name_list
}

proc altera_iosubsystem_get_pll_inclock_name {lvds_instance_name} {
	
	set lvds_core_instance_name "${lvds_instance_name}|arch_inst"
	set pll_instance_name "$lvds_core_instance_name|internal_pll.pll_inst|tennm_pll" 

	
	set catch_exception [catch {
		set pll_refclk_node [get_nodes "$pll_instance_name|refclk[0]"]
		set ref_ck_port_id [altera_iosubsystem_get_input_clk_id $pll_refclk_node]
		set ref_ck_port_name [get_port_info -name $ref_ck_port_id]
	} ]
	if {$catch_exception == 0} {
		set ref_ck_pin $ref_ck_port_name
	} else {
		set ref_ck_pin "${lvds_instance_name}_inclock_export"
	}

	return $ref_ck_pin
}

proc altera_iosubsystem_get_current_timequest_report_folder {} {

   set catch_exception [catch {get_current_timequest_report_folder} error_message]
   if {[regexp ERROR $error_message] == 1} {
      return "ReportDDR"
   } else {
      return [get_current_timequest_report_folder]
   }
}

proc altera_iosubsystem_report_rskm {} {

   set RX_NON_DPA_IP_TRAIL "|core|arch_inst|rx_channels[0].rx_non_dpa.serdes_dpa_inst~rx_internal_reg"
   set RX_NON_DPA_REG_TRAIL {|core|arch_inst|rx_channels[*].rx_non_dpa.serdes_dpa_inst~rx_internal_reg}
   set RX_NON_DPA_FCLK_TRAIL "|core|arch_inst|*_channels[*].*.lvds_clock_tree_inst|lvds_clk_0"
   set RX_NON_DPA_LVDSIN_TRAIL {|core|arch_inst|rx_channels[*].rx_non_dpa.serdes_dpa_inst|fclk_in}

   set orig_op_cond [get_operating_conditions]

	set sw 300

   load_package report
   catch {load_report} load_report_out
   set report_not_loaded [regexp "ERROR" $load_report_out]
   if {$report_not_loaded == 1} {
      create_report_database -type cmp
      create_report_database -type taw
   }
	
	set current_tq_folder_name [altera_iosubsystem_get_current_timequest_report_folder]
   if {[string match "*GUI*" $current_tq_folder_name]} {
      set is_gui 1
   } else {
      set is_gui 0
   }
   if {[get_report_panel_id $current_tq_folder_name] == -1} {
      set panel_id [create_report_panel -folder $current_tq_folder_name]
   }

   set non_dpa_keepers_collection [get_keepers -nowarn "*${RX_NON_DPA_IP_TRAIL}"]
   if {[get_collection_size $non_dpa_keepers_collection] == 0} {
      post_message -type info "No Non-DPA RX instances detected to report RSKM"
   }

   foreach_in_collection i_non_dpa_keeper $non_dpa_keepers_collection {
      set keeper_name [altera_iosubsystem_get_timequest_name [get_node_info -name $i_non_dpa_keeper]]
      set lvds_instance_name [string range $keeper_name 0 [expr [string length $keeper_name] - [string length $RX_NON_DPA_IP_TRAIL] - 1]]
      set panel_name $lvds_instance_name
      set fclk_name "${lvds_instance_name}${RX_NON_DPA_FCLK_TRAIL}"
      foreach_in_collection lvds_node [get_nodes -nowarn "$lvds_instance_name|*|fclk"] {
         set fclk_name [get_node_info -name [get_edge_info -src [get_node_info -clock_edges [lindex $lvds_node 0]]]]
         break
      }
      set reg_name "${lvds_instance_name}${RX_NON_DPA_REG_TRAIL}"
      set lvdsin_name "${lvds_instance_name}${RX_NON_DPA_LVDSIN_TRAIL}"

      if { ! [string match "${current_tq_folder_name}*" $panel_name] } {
         set panel_name "${current_tq_folder_name}||$panel_name"
      }

      set panel_id [get_report_panel_id $panel_name]
      if {$panel_id != -1} {
         delete_report_panel -id $panel_id
      }

      set panel_id [create_report_panel -table $panel_name]

      if {$::RSKM_USE_MICRO == 1} {
         if {$is_gui == 1} {
            set setup_rpt [report_timing -setup -through $lvdsin_name -to [get_keepers $reg_name] ]
            set setup [lindex $setup_rpt 1]
            set hold_rpt [report_timing -hold -through $lvdsin_name -to [get_keepers $reg_name] ]
            set hold [lindex $hold_rpt 1]
            set rskm [expr min($setup, $hold)]
            post_message -type info "Micro RSKM of <$lvds_instance_name> = $rskm"

            if { ! [string match "${current_tq_folder_name}*" $panel_name] } {
               set panel_name "${current_tq_folder_name}||$panel_name"
            }

            add_row_to_table -id $panel_id [list "RSKM" "Worst-Case Setup Slack" "Worst-Case Hold Slack" "RCCS"]
            add_row_to_table -id $panel_id [list $rskm $setup $hold $::RCCS]
         } else {
            set rskm "_UNDEFINED"
            set header_row [list "LVDS Receiver Worst-case RSKM"]
            set data_row [list $rskm]

            foreach_in_collection i_op [get_available_operating_conditions] { 
               set i_op_name [get_operating_conditions_info -name $i_op] 
               set_operating_conditions $i_op
               update_timing_netlist
               set setup_rpt_at_op [report_timing -setup -through $lvdsin_name -to [get_keepers $reg_name] ]
               set setup_at_op [lindex $setup_rpt_at_op 1]
               set hold_rpt_at_op [report_timing -hold -through $lvdsin_name -to [get_keepers $reg_name] ]
               set hold_at_op [lindex $hold_rpt_at_op 1]
               if {$rskm == "_UNDEFINED"} {
                  set rskm [expr min($setup_at_op, $hold_at_op)]
               } else {
                  set rskm [expr min($rskm, $setup_at_op, $hold_at_op)]
               }

               lappend header_row "Setup:$i_op_name"
               lappend data_row $setup_at_op
               lappend header_row "Hold:$i_op_name"
               lappend data_row $hold_at_op
            }

            lset data_row 0 $rskm

            add_row_to_table -id $panel_id $header_row
            add_row_to_table -id $panel_id $data_row

         }
      } else {
         set fclk_target_name [get_node_info -name [get_edge_info -src [get_node_info -clock_edges $fclk_name]]]
         set fclk_setting_name [altera_iosubsystem_get_clock_name_from_target $fclk_target_name]
         set period [expr [get_clock_info -period [get_clocks [lindex $fclk_setting_name 0]]] * 1000]
         set rskm [expr 0.5 * ($period - $sw - $::RCCS)]
         post_message -type info "RSKM of <$lvds_instance_name> = $rskm"

         add_row_to_table -id $panel_id [list "RSKM" "LVDS Period" "Sampling Window" "RCCS"]
         add_row_to_table -id $panel_id [list $rskm $period $sw $::RCCS]

      }
   }

   if {$is_gui == 0} {
      set_operating_conditions $orig_op_cond
      update_timing_netlist
   }
}

proc altera_iosubsystem_report_tccs {} {
   set TX_IP_TRAIL "|core|arch_inst|tx_channels[0].tx.serdes_dpa_inst~tx_internal_reg"

   set orig_op_cond [get_operating_conditions]

   load_package report
   catch {load_report} load_report_out
   set report_not_loaded [regexp "ERROR" $load_report_out]
   if {$report_not_loaded == 1} {
      create_report_database -type cmp
      create_report_database -type taw
   }
	
	set current_tq_folder_name [altera_iosubsystem_get_current_timequest_report_folder]
   if {[string match "*GUI*" $current_tq_folder_name]} {
      set is_gui 1
   } else {
      set is_gui 0
   }

   if {[get_report_panel_id $current_tq_folder_name] == -1} {
      set panel_id [create_report_panel -folder $current_tq_folder_name]
   }

   set tx_keepers_collection [get_keepers -nowarn "*${TX_IP_TRAIL}"]
   if {[get_collection_size $tx_keepers_collection] == 0} {
      post_message -type info "No TX instances detected to report TCCS"
   }

   foreach_in_collection i_tx_keeper $tx_keepers_collection {
      set keeper_name [altera_iosubsystem_get_timequest_name [get_node_info -name $i_tx_keeper]]
		set lvds_instance_name [string range $keeper_name 0 [expr [string length $keeper_name] - [string length $TX_IP_TRAIL] - 1]]
      set panel_name [string range $keeper_name 0 [expr [string length $keeper_name] - [string length $TX_IP_TRAIL] - 1]]

      if { ! [string match "${current_tq_folder_name}*" $panel_name] } {
         set panel_name "${current_tq_folder_name}||$panel_name"
      }

      set panel_id [get_report_panel_id $panel_name]
      if {$panel_id != -1} {
         delete_report_panel -id $panel_id
      }
      
      set panel_id [create_report_panel -table $panel_name]
		set i_tccs 0


      if {$::TCCS_USE_MICRO == 0} {
         set header_row [list "LVDS Transmitter Constant TCCS"]
         set data_row [list 330]
      } else {
         if {$is_gui == 1} {
            set header_row [list "LVDS Transmitter TCCS"]
            set i_tccs [lindex [report_skew -from "${lvds_instance_name}|*~tx_internal_reg" -npaths 100] 1]
            set data_row [list $i_tccs]
         } else {
         
            set header_row [list "LVDS Transmitter Worst-case TCCS"]
            set data_row [list $i_tccs]
            

            foreach_in_collection i_op [get_available_operating_conditions] { 
               set i_op_name [get_operating_conditions_info -name $i_op] 
               set_operating_conditions $i_op
               update_timing_netlist
               set i_tccs_at_op [lindex [report_skew -from "${lvds_instance_name}|*~tx_internal_reg" -npaths 100] 1]
               lappend header_row $i_op_name
               lappend data_row $i_tccs_at_op
               if {$i_tccs < $i_tccs_at_op} {
                  set i_tccs $i_tccs_at_op
               }
            }

            lset data_row 0 $i_tccs
         }
      }
      add_row_to_table -id $panel_id $header_row
      add_row_to_table -id $panel_id $data_row

   }

   if {$is_gui == 0} {
      set_operating_conditions $orig_op_cond
      update_timing_netlist
   }

	
}

proc altera_iosubsystem_round_3dp { x } {
   return [expr { round($x * 1000) / 1000.0  } ]
}

proc altera_iosubsystem_get_periphery_clock_uncertainty { results_array_name } {
   upvar 1 $results_array_name results

#  set speed_temp_grade [get_speedgrade_name]

   set c2p_setup  [altera_iosubsystem_round_3dp 0.0]
   set c2p_hold   [altera_iosubsystem_round_3dp 0.0]
   set p2c_setup  [altera_iosubsystem_round_3dp 0.0]
   set p2c_hold   [altera_iosubsystem_round_3dp 0.0]

   set results [list $c2p_setup $c2p_hold $p2c_setup $p2c_hold]
}

#proc: altera_iosubsystem_get_clock_source
#
#  Get the first register mapped clock source by traversing fanins of clock
#  edges.  A node is deemed "register mapped" if it does not contain
#  `io48tilelvds`, hence this function is valid only for the IO subsystem
#
# parameters:
#
# node - TimeQuest node to get clock source of
#
# returns:
#
# Register maped clock node.
#

proc altera_iosubsystem_get_clock_source {node} {
   set clock_node ""
   catch {get_node_info -name [get_edge_info -src [get_node_info -clock_edges $node]]} clock_node

   if {$clock_node eq ""} {
      post_message -type error "Failed to find clock source of node '$node'"
   }

   if {[regexp {io48tilelvds} $clock_node]} {
       return [altera_iosubsystem_get_clock_source $clock_node]
   }

   return $clock_node
}

#Set max delay if in fit flow, otherwise set false path from "from_pin" to
#fanouts of "to_pin"
proc set_max_delay_in_fit_or_false_path_in_sta_to_fanout {from_pin to_pin delay} {
    upvar 1 fit_flow l_fit_flow

    set fanouts [get_fanouts $to_pin]
    if {$l_fit_flow == 1} { 
        set_max_delay -from $from_pin -to $fanouts $delay
    } else { 
        set_false_path -from $from_pin -to $fanouts
    } 
}

#Set max delay if in fit flow, otherwise set false path from "from_pin" to
#fanouts of "to_pin"
#Check for existence of fanouts before doing so.
proc set_max_delay_in_fit_or_false_path_in_sta_to_fanout_no_warn {from_pin to_pin delay} {
    upvar 1 fit_flow l_fit_flow

    if {[get_collection_size [get_pins -nowarn $to_pin]] <= 0 } { return }
    set fanouts [get_fanouts $to_pin]
    if {[get_collection_size $fanouts] <= 0} { return }

    if {$l_fit_flow == 1} { 
        set_max_delay -from $from_pin -to $fanouts $delay
    } else { 
        set_false_path -from $from_pin -to $fanouts
    } 
}

#Set max delay if in fit flow, otherwise set false path through "through_pin"
proc set_false_path_in_sta_through_no_warn {through_pin delay} {
    upvar 1 fit_flow l_fit_flow

    if {$l_fit_flow != 1} { 
    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }

        set_false_path -through $through_pin_collection
    } 
}

#Set max delay if in fit flow, otherwise set false path through "through_pin"
proc set_max_delay_in_fit_or_false_path_in_sta_through_no_warn {through_pin delay} {
    upvar 1 fit_flow l_fit_flow

    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }

    if {$l_fit_flow == 1} { 
        set_max_delay -through $through_pin_collection $delay
    } else { 
        set_false_path -through $through_pin_collection
    } 
}

#Set min delay if in fit flow, otherwise set false path from "from_pin" to
#fanouts of "to_pin"
proc set_min_delay_in_fit_or_false_path_in_sta_to_fanout {from_pin to_pin delay} {
    upvar 1 fit_flow l_fit_flow

    set fanouts [get_fanouts $to_pin]
    if {$l_fit_flow == 1} { 
        set_min_delay -from $from_pin -to $fanouts $delay
    } else { 
        set_false_path -from $from_pin -to $fanouts
    } 
}

#Set min delay if in fit flow, otherwise set false path from "from_pin" to
#fanouts of "to_pin"
#Check for existence of fanouts before doing so.
proc set_min_delay_in_fit_or_false_path_in_sta_to_fanout_no_warn {from_pin to_pin delay} {
    upvar 1 fit_flow l_fit_flow

    if {[get_collection_size [get_pins -nowarn $to_pin]] <= 0 } { return }
    set fanouts [get_fanouts $to_pin]
    if {[get_collection_size $fanouts] <= 0} { return }

    if {$l_fit_flow == 1} { 
        set_min_delay -from $from_pin -to $fanouts $delay
    } else { 
        set_false_path -from $from_pin -to $fanouts
    } 
}

#Set min delay if in fit flow, otherwise set false path through "through_pin"
proc set_min_delay_in_fit_or_false_path_in_sta_through_no_warn {through_pin delay} {
    upvar 1 fit_flow l_fit_flow

    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }

    if {$l_fit_flow == 1} { 
        set_min_delay -through $through_pin_collection $delay
    } else { 
        set_false_path -through $through_pin_collection
    } 
}

#Disable min pulse width check to keeper, if it exists.
proc disable_min_pulse_width_no_warn {keeper} {
    set keeper_collection [get_nodes -nowarn $keeper]
    if {[get_collection_size $keeper_collection] <= 0} { return }

    disable_min_pulse_width $keeper
}


#proc: altera_iosubsystem_get_iopll_atom
#
#  Given a lvds core instance name it finds the IOPLL its connected to.
#  Checks via both fclk and loaden.
#
#  parameters:
#  lvds_core_instance_name -> string (the one ending in "arch_inst")
#  is_tx_outclock -> int for different search types, usually based on LVDS mode
#
#  returns:
#  atom id (empty if not found)
#
proc altera_iosubsystem_get_iopll_atom { lvds_core_instance_name is_tx_outclock } {
    set atom_type IOPLL
    set search_iter 10
    set pll_atom [altera_iosubsystem_get_atom_by_lvds_input $lvds_core_instance_name $is_tx_outclock $atom_type $search_iter "fclk"]
    if {$pll_atom ne ""} {
        return $pll_atom
    }
    set pll_atom [altera_iosubsystem_get_atom_by_lvds_input $lvds_core_instance_name $is_tx_outclock $atom_type $search_iter "loaden"]
    if {$pll_atom ne ""} {
        return $pll_atom
    }
    set pll_atom [altera_iosubsystem_get_atom_by_lvds_input $lvds_core_instance_name $is_tx_outclock $atom_type $search_iter "dpa_reg"]
    return $pll_atom
}

#proc: altera_iosubsystem_get_clock_tree_atom
#
#  Given a lvds core instance name it finds the clock tree its connected to.
#  Checks via both fclk and loaden.
#
#  parameters:
#  lvds_core_instance_name -> string (the one ending in "arch_inst")
#  is_tx_outclock -> int for different search types, usually based on LVDS mode
#
#  returns:
#  atom id (empty if not found)
#

#proc: altera_iosubsystem_get_atom_by_lvds_input
#
#  Searches for an atom, starting from the lvds_input of the LVDS
#
#  returns:
#  atom id (empty if not found)
#
proc altera_iosubsystem_get_atom_by_lvds_input { lvds_core_instance_name is_tx_outclock atom_type search_iter lvds_input } {
    set lvds_core_instance_name [regsub -all {\[\d*\]} $lvds_core_instance_name "\[\*\]"]

    set node [altera_iosubsystem_get_lvds_node $lvds_core_instance_name $is_tx_outclock $lvds_input]
    if {$node eq ""} {
        return ""
    }
    set found_atom [altera_iosubsystem_search_back_from_node_to_atom $node $atom_type $search_iter]
    return $found_atom
}

#proc: altera_iosubsystem_get_lvds_node
#
#  Picks the correct LVDS node based on mode
#
#  returns:
#  LVDS node
#
proc altera_iosubsystem_get_lvds_node { lvds_core_instance_name is_tx_outclock lvds_input } {
    set node ""
    if {$is_tx_outclock == 1} {
        foreach_in_collection node [get_nodes -nowarn "$lvds_core_instance_name*channel*$lvds_input*"] { break }
    } elseif {$is_tx_outclock == 2} {
        foreach_in_collection node [get_nodes -nowarn "$lvds_core_instance_name*$lvds_input*"] { break }
    } else {
        foreach_in_collection node [get_nodes -nowarn "$lvds_core_instance_name*$lvds_input*"] { break }
    }
    return $node
}

#proc: altera_iosubsystem_node_is_type
#
#  Check if node has this atom type
#
#  parameters:
#  node -> the node to check
#  atom_type -> string saying type of atom to check
#
#  returns:
#  Empty if mismatch, atom id if match
#
proc altera_iosubsystem_node_is_type { node atom_type } {
    set cell [get_node_info -cell $node]
    set cell_name [get_cell_info -name $cell]                
    set ix [string last _ $cell]
    if {$ix < 0} {
        return ""
    }
    incr ix 1
    set cell_id [string range $cell $ix [string length $cell]]
    set cell_type [get_atom_node_info -key TYPE -node $cell_id]

    if {![string match -nocase "*$atom_type*" $cell_type]} {
        return ""
    }

    set atom_name [get_atom_node_info -key NAME -node $cell_id]
    if {$atom_name eq $cell_name} {
        return $cell_id
    }
    return ""
}

#proc: altera_iosubsystem_search_back_from_node_to_atom
#
#  DFS from node backwards to find the atom of atom_type.
#  Use clock edges for the traversal
#
#  parameters:
#  node -> the node to start searching from
#  atom_type -> string saying type of atom to check
#  search_iter -> Maximum hops to take
#
#  returns:
#  Empty if not found, atom id if found
#
proc altera_iosubsystem_search_back_from_node_to_atom { node atom_type search_iter } {
    set found_node [altera_iosubsystem_node_is_type $node $atom_type]
    if {$found_node ne ""} {
        return $found_node
    }
    if {$search_iter <= 0} {
        return ""
    }
    incr search_iter -1
    foreach edge [get_node_info -clock_edges $node] {
        set src_node [get_edge_info -src $edge]
        set found_node [altera_iosubsystem_search_back_from_node_to_atom $src_node $atom_type $search_iter]
        if {$found_node ne ""} {
            return $found_node
        }
    }
    return ""
}


proc get_iopll_clocks { iopll_atom } {
   set pll_name [get_atom_node_info -key NAME -node $iopll_atom]

    set clk_root $pll_name 
    for {set i 0} {$i < 2 } {incr i} {
        set ix [string last | $clk_root]
         if {$ix >= 0} {
             incr ix -1
             set clk_root [string range $clk_root 0 $ix]
         }
    }
    
    return [get_clocks $clk_root*]

}


proc convert_bigtime_period_ns {param} {
    set param_unitless [string trimright $param {MHz}]
    return [expr (1/$param_unitless)*1000]
}


proc convert_ps_to_degrees {param period} {
    return [expr ([string trimright $param ps])*360/$period]
}


set ::RSKM_USE_MICRO 0
set ::TCCS_USE_MICRO 0
 12 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 2 ip 12 subsys_sgmii 20 gmii_sgmii_adapter_0 33 altera_gmii_to_sgmii_adapter_1922 5 synth 39 altera_gmii_to_sgmii_adapter_agilex.sdc 3219 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


## Identify HPS EMAC clock
set fanin_keeper_list ""
set fanins [get_fanins [get_keepers "[get_current_instance]|*u_txbuffer|wr_data_flp\[0\]"] -clock]
if {[get_collection_size $fanins] != 0} {
    foreach_in_collection fanin_keeper $fanins {
        lappend fanin_keeper_list [get_node_info $fanin_keeper -name]
    }

    ## Identify HPS EMAC CLOCK
    if {[regexp {emac1_gmii_txclk_cm.reg} $fanin_keeper_list]} {
        set emac_clk "hps_emac1_gtx_clk"
        declare_clock $emac_clk
    } elseif {[regexp {emac2_gmii_txclk_cm.reg} $fanin_keeper_list]} {
        set emac_clk "hps_emac2_gtx_clk"
        declare_clock $emac_clk
    } else {
        set emac_clk 0
    }
    
    if {$emac_clk != 0} {
        ## Get PCS_CLOCK path
        set pcs_clock ""
        foreach fanin_keeper_node $fanin_keeper_list { 
            foreach_in_collection i [get_clocks -nowarn] {
				if {![is_clock_defined $i]} {
					continue
				}
				if { [catch { get_node_info -name  [get_clock_info -targets $i] } i_target ] } {
					continue
				}
				if {[string equal $fanin_keeper_node $i_target]} {
					set clock_temp [get_clock_info -name $i]
					if {![string equal $clock_temp $emac_clk]} {
						lappend pcs_clock $clock_temp
					}
				}
			}
        }
		
		if {$pcs_clock != ""} {
			# False Path PCS_CLOCK to GMII Reg
			set_false_path -from [get_clocks $pcs_clock] -to [get_registers "[get_current_instance]|u_txbuffer|wr_data_flp\[*\]"]
			# Async clock group between PCS_CLOCK and EMAC_CLK
			set_clock_groups -asynchronous -group [get_clocks $pcs_clock] -group [get_clocks $emac_clk]
		}
        # False Path Falling Edge of EMAC_CLK to GMII Reg
        set_false_path -fall_from [get_clocks $emac_clk] -to [get_registers "[get_current_instance]|u_txbuffer|wr_data_flp\[*\]"]
    }
}

# False Path on reset sync clrn
set_false_path -to [get_pins [get_current_instance]|u_reset_blk|u_mac_rst_rx_pcs|din_sync_*|clrn]
set_false_path -to [get_pins [get_current_instance]|u_reset_blk|u_mac_rst_tx_pcs|din_sync_*|clrn]
set_false_path -to [get_pins [get_current_instance]|u_reset_blk|u_sw_tx_rst_mac|din_sync_*|clrn]
set_false_path -to [get_pins [get_current_instance]|u_reset_blk|u_sw_tx_rst_pcs|din_sync_*|clrn]

# MII data path doesn't need to meet 125MHz. 
set_multicycle_path 5 -setup -end -to [get_registers [get_current_instance]|mii_rd_data_reg[*]]
set_multicycle_path 4 -hold -end -to [get_registers [get_current_instance]|mii_rd_data_reg[*]]
 10 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 8 qsys_top 28 altera_reset_controller_1921 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 10 0 1 / 4 home 5 wisig 3 sam 12 success_ghrd 22 agilex_soc_devkit_ghrd 12 subsys_sgmii 28 altera_reset_controller_1921 5 synth 27 altera_reset_controller.sdc 1620 # (C) 2001-2022 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0
set aclr_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase *|alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 0
